{"version":3,"sources":["CustomCard.js","Menu.js","Square.js","MessagesForCard.js","animateMethods.js","Board.js","QueryBackend.js","index.js"],"names":["MyCard","props","loader","holder","i","messages","length","push","Card","Title","key","header","Text","loading","className","Header","Button","id","onClick","clearMessages","bind","Body","Menu","barrierButton","dictionary","barrier","weightButton","useState","Array","fill","dropDownMenu","setDropDownMenu","toggleOpen","temp","createBarrier","setWeightButtonFunction","setBarrier","document","getElementById","innerText","setWeightButton","menuClass1","menuClass2","role","type","data-toggle","aria-haspopup","aria-expanded","aria-labelledby","backendDepthFirstSearch","backendBreathFirstSearch","backendDijkstra","generatePrimsMaze","generateBacktrack","clearGraph","randomizeWeights","clearWeights","generatePrimsTree","Square","state","hover","weight","onMouseEnterSquare","onMouseLeaveSquare","console","log","this","setState","nextProps","nextState","nextContext","stateId","textColor","divStyle","background","color","variant","style","onMouseEnter","onMouseLeave","React","Component","MessagesForCard","cardMessages","backendOrFrontEnd","setCardMessages","setBackEndOrFrontEnd","setLoading","backendResponse","date1","data","date2","Date","time","Math","abs","updateMessages","frontendInitialMessage","message","messageSeparator","sender","unshift","slice","clearCardMessages","animateMethods","squares","setSquares","addToast","animateTrail","tickIndex","tickArr","animationTrail","finishAnimationTrail","current","animateWithoutReturnPath","arr","startMarkerIndex","endMarkerIndex","timerID2","setInterval","tick2","resetBoardOnAlgorithmRun","clearInterval","returnToast","animateWithReturnPath","findPathArr","shortestPathArr","finishedAnimatingFindPath","toast","appearance","autoDismiss","Board","testingUrl","HEIGHT","heightAndWidth","WIDTH","SIZE","blockedNodes","setBlockedNodes","weights","setWeights","setStartMarkerIndex","setEndMarkerIndex","useToasts","messagesForCard","animateMethod","queryBackendSPF","urlSuffix","animate","a","axios","post","then","res","catch","err","error","queryBackendHigherOrderFunctionSPF","queryBackendMaze","tempBlockedNodes","queryBackendHigherOrderFunctionMaze","r","checkForValidMarkers","setStartAndEndLocations","markerMethod","index","deselected","resetBoardOnDestinationChange","setMarker","toastMessage","tempSquares","setNodeToBlocked","start","floor","random","nodeArr","finalWeights","directionOfEdges","tempWeights","renderSquare","count","fork","setWeight","parent","children","j","menuDictionaryMethods","Game","autoDismissTimeout","placement","ReactDOM","render"],"mappings":"yTAkCeA,EA7BA,SAACC,GAGZ,IADA,IAMIC,EANEC,EAAS,GACPC,EAAI,EAAGA,EAAIH,EAAMI,SAASC,OAAQF,IAEtCD,EAAOI,KAAM,kBAACC,EAAA,EAAKC,MAAN,CAAYC,IAAO,QAAUN,GAAKH,EAAMU,OAAOP,KAC5DD,EAAOI,KAAO,kBAACC,EAAA,EAAKI,KAAN,CAAWF,IAAO,UAAYN,GAAIH,EAAMI,SAASD,KAUnE,OAPGH,EAAMY,UAELX,EAAU,yBAAKY,UAAY,iBACvB,kBAAC,IAAD,QAKR,kBAACN,EAAA,EAAD,CAAMM,UAAU,eACZ,kBAACN,EAAA,EAAKO,OAAN,KACI,kBAACC,EAAA,EAAD,CAAQC,GAAI,eAAgBC,QAAWjB,EAAMkB,cAAcC,U,IAA3D,kBADJ,8BAKA,kBAACZ,EAAA,EAAKa,KAAN,KACKnB,EACAC,KCsDEmB,EAhFF,SAACrB,GAEV,IAAIsB,EAAgBtB,EAAMuB,WAAWC,QACjCC,EAAezB,EAAMuB,WAAWE,aAFxC,EAG4CC,mBAASC,MAAM,GAAGC,MAAK,IAHnE,mBAGWC,EAHX,KAGyBC,EAHzB,KAIUC,EAAa,SAAC5B,GAEhB,IAAM6B,EAAO,EAAC,GAAO,GACrBA,EAAK7B,IAAM0B,EAAa1B,GACxB2B,EAAgBE,IAEdC,EAAgB,WACfR,GACCS,IACJZ,GAAiBA,EACjBtB,EAAMuB,WAAWY,WAAWb,GAExBc,SAASC,eAAe,WAAWC,UADnChB,EAC+C,kBAEA,gBAEjDY,EAA0B,WAEzBZ,GACCW,IACJR,GAAgBA,EAChBzB,EAAMuB,WAAWgB,gBAAgBd,GAE7BW,SAASC,eAAe,cAAcC,UADvCb,EACmD,qBAEA,eAEpDe,EAAU,wBAAqBX,EAAa,GAAI,QAAS,IACzDY,EAAU,wBAAqBZ,EAAa,GAAI,QAAS,IAC/D,OACQ,yBAAKb,GAAK,WAAWH,UAAY,qBAAqB6B,KAAM,SACxD,yBAAK7B,UAAU,YAAY6B,KAAK,SAC5B,4BAAQ1B,GAAG,eAAe2B,KAAK,SAAU1B,QAAWc,EAAWZ,U,EAAW,GAAIN,UAAU,kCAChF+B,cAAY,gBAAgBC,gBAAc,OAAOC,gBAAc,SADvE,4BAIA,yBAAKjC,UAAW2B,EAAYO,kBAAgB,iBACxC,uBAAG/B,GAAI,aAAcH,UAAY,gCAAgCI,QAAYjB,EAAMuB,WAAWyB,wBAAwB7B,U,IAAtH,qBAEI,kDAEJ,uBAAGH,GAAI,aAAcH,UAAY,gCAAgCI,QAAYjB,EAAMuB,WAAW0B,yBAAyB9B,U,IAAvH,sBAEI,+CAEJ,uBAAGH,GAAI,aAAcH,UAAY,gCAAgCI,QAAYjB,EAAMuB,WAAW2B,gBAAgB/B,U,IAA9G,oBAKR,yBAAKN,UAAU,YAAY6B,KAAK,SAC5B,4BAAQ1B,GAAG,eAAe2B,KAAK,SAAU1B,QAAWc,EAAWZ,U,EAAW,GAAIN,UAAU,kCAChF+B,cAAY,gBAAgBC,gBAAc,OAAOC,gBAAc,SADvE,8BAIA,yBAAKjC,UAAW4B,EAAYM,kBAAgB,kBACxC,uBAAG/B,GAAI,aAAcH,UAAY,iCAAiCI,QAAYjB,EAAMuB,WAAW4B,kBAAkBhC,U,IAAjH,eAGA,uBAAGH,GAAI,aAAcH,UAAY,iCAAiCI,QAAYjB,EAAMuB,WAAW6B,kBAAkBjC,U,IAAjH,4BAMR,kBAACJ,EAAA,EAAD,CAAQF,UAAY,uCAAuCI,QAAWjB,EAAMuB,WAAW8B,WAAWlC,U,IAAlG,eACA,kBAACJ,EAAA,EAAD,CAAQF,UAAY,uCAAwCG,GAAK,UAAUC,QAAYgB,EAAcd,U,IAArG,gBACA,kBAACJ,EAAA,EAAD,CAAQF,UAAY,uCAAuCG,GAAI,aAAaC,QAAYiB,EAAwBf,U,IAAhH,eACA,kBAACJ,EAAA,EAAD,CAAQF,UAAY,uCAAuCG,GAAI,mBAAmBC,QAAYjB,EAAMuB,WAAW+B,iBAAiBnC,U,IAAhI,qBACA,kBAACJ,EAAA,EAAD,CAAQF,UAAY,uCAAuCG,GAAK,mBAAmBC,QAAYjB,EAAMuB,WAAWgC,aAAapC,U,IAA7H,kBACA,kBAACJ,EAAA,EAAD,CAAQF,UAAY,uCAAuCG,GAAK,mBAAmBC,QAAYjB,EAAMuB,WAAWiC,kBAAkBrC,U,IAAlI,4D,gBCdDsC,E,kDA9DX,WAAYzD,GAAQ,IAAD,8BACf,cAAMA,IACD0D,MAAQ,CACTC,OAAO,EACP3C,GAAI,OACJ4C,OAAQ,GAEZ,EAAKC,mBAAqB,EAAKA,mBAAmB1C,KAAxB,gBAC1B,EAAK2C,mBAAqB,EAAKA,mBAAmB3C,KAAxB,gBAC1B,EAAKF,QAAU,EAAKA,QAAQE,KAAb,gBATA,E,iEAaf4C,QAAQC,IAAI,eAAkBC,KAAKjE,MAAMgB,IACpB,UAAlBiD,KAAKjE,MAAMgB,IAEdiD,KAAKC,SAAS,CACVlD,GAAI,MACJ2C,OAAO,M,2CAKXM,KAAKC,SAAS,CACVlD,GAAI,OACJ2C,OAAO,M,gCAIXM,KAAKjE,MAAMiB,Y,4CAEOkD,EAAWC,EAAWC,GAExC,OAAQD,EAAUpD,KAAOiD,KAAKP,MAAM1C,IAAMiD,KAAKjE,MAAM4D,SAAWO,EAAUP,QAAUK,KAAKjE,MAAMgB,KAAOmD,EAAUnD,K,+BAGhH,IAAIsD,EACAC,EAAY,QAKD,WADXD,EAHAL,KAAKP,MAAMC,MAGDM,KAAKP,MAAM1C,GAFXiD,KAAKjE,MAAMgB,KAGa,UAAZsD,IACtBC,EAAY,SAChB,IAAMC,EAAW,CACbC,WAAYH,EACZI,MAAOH,GAEX,OACI,kBAACxD,EAAA,EAAD,CACI4D,QAAQ,YACR9D,UAAU,SACV+D,MAASJ,EACTK,aAAcZ,KAAKJ,mBAAmB1C,OACtC2D,aAAcb,KAAKH,mBAAmB3C,OACtCF,QAASgD,KAAKhD,QAAQE,QACrB8C,KAAKjE,MAAM4D,Y,GAzDPmB,IAAMC,W,iBCsCZC,EAnCX,WAAYC,EAAcC,EAAmBC,EAAiBC,EAAsBC,GACnF,IAAD,gCAOAC,gBAAkB,SAACC,EAAOC,GACtB,EAAKH,YAAW,GAChB,IAAMI,EAAQ,IAAIC,KACZC,EAAOC,KAAKC,IAAIJ,EAAQF,GAC9B,EAAKO,eAAeN,EAAM,WAC1B,EAAKM,eAAe,0BAA4BH,EAAO,gBAAiB,aAZ5E,KAeAI,uBAAyB,SAACC,GACtB,EAAKX,YAAW,GAChB,EAAKY,mBACL,EAAKH,eAAeE,EAAS,aAlBjC,KAoBAC,iBAAmB,WACf,EAAKH,eAAe,IAAK,iCArB7B,KAuBAA,eAAiB,SAACN,EAAMU,GACpB,EAAKjB,aAAakB,QAAQX,GAC1B,EAAKN,kBAAkBiB,QAAQD,GAC/B,EAAKf,gBAAgB,EAAKF,aAAamB,SACvC,EAAKhB,qBAAqB,EAAKF,kBAAkBkB,UA3BrD,KA6BAC,kBAAoB,WAChB,EAAKlB,gBAAgB,IACrB,EAAKC,qBAAqB,KA9B1BpB,KAAKqB,WAAaA,EAClBrB,KAAKiB,aAAeA,EACpBjB,KAAKkB,kBAAoBA,EACzBlB,KAAKmB,gBAAkBA,EACvBnB,KAAKoB,qBAAuBA,GCoGrBkB,EA7GX,WAAYC,EAASC,EAAYC,GAChC,IAAD,gCAMAC,aAAe,SAACC,EAAWC,GAEvB,EAAKL,QAAQK,EAAQD,IAAc,SAChCA,EAAY,EAAKE,iBAChB,EAAKN,QAAQK,EAAQD,EAAU,EAAKE,iBAAmB,UAV/D,KAYAC,qBAAuB,SAACC,EAASH,EAASD,GAKtC,OAHA,EAAKJ,QAAQK,EAAQD,EAAUI,IAAY,QAC3CA,IACA,EAAKP,WAAW,EAAKD,QAAQH,SACtBW,GAjBX,KAmBAC,yBAA2B,SAACC,EAAKC,EAAkBC,GAC/C,IAAIR,EAAY,EACZI,EAAU,EAAKF,eACbO,EAAWC,aAAY,kBAAMC,EAAML,KAAM,IAC/C,EAAKM,yBAAyBL,EAAkBC,GAChD,IAAMG,EAAQ,SAACV,GACPD,EAAYC,EAAQxG,OAAS,GAE7B,EAAKsG,aAAaC,EAAWC,GAC7BD,IACA,EAAKH,WAAW,EAAKD,QAAQH,UAEzBW,EAAU,EACVA,EAAU,EAAKD,qBAAqBC,EAASH,EAASD,IAGtDa,cAAcJ,GACd,EAAKK,YAAYb,MApCjC,KAyCAc,sBAAwB,SAACT,EAAKC,EAAkBC,GAC5C,IAAMQ,EAAcV,EAAI,GAClBW,EAAkBX,EAAI,GACtBG,EAAWC,aAAY,kBAAMC,EAAMK,EAAaC,KAAkB,IACpEjB,EAAY,EAChB,EAAKY,yBAAyBL,EAAkBC,GAChD,IAAIU,GAA4B,EAC1BP,EAAQ,SAACK,EAAaC,GACxB,GAAKC,EAgBGlB,EAAYiB,EAAgBxH,OAAS,GACrC,EAAKmG,QAAQqB,EAAgBjB,IAAc,OAC3C,EAAKH,WAAW,EAAKD,QAAQH,SAC7BO,MAEA,EAAKJ,QAAQqB,EAAgBA,EAAgBxH,OAAS,IAAM,OAC5D,EAAKoG,WAAW,EAAKD,QAAQH,SAC7BoB,cAAcJ,QAvBU,CAC5B,GAAIT,GAAagB,EAAYvH,OACzB,IAAK,IAAIF,EAAI,EAAGA,EAAI,EAAGA,IAEfyG,GAAagB,EAAYvH,QAAUuH,EAAYhB,KAAeQ,GAAkBQ,EAAYhB,KAAeO,IAC3G,EAAKX,QAAQoB,EAAYhB,IAAc,SAE3CA,SAGJkB,GAA4B,EAC5B,EAAKtB,QAAQY,GAAkB,OAC/BR,EAAY,EAEhB,EAAKH,WAAW,EAAKD,QAAQH,YA/DzC,KA6EAqB,YAAc,SAACb,GAEX,OAAoC,IAAhCA,EAAQA,EAAQxG,OAAS,GAClB,EAAK0H,MAAM,sBAAuB,WAAW,IAEpD,EAAKvB,QAAQK,EAAQA,EAAQxG,OAAS,IAAM,OAC5C,EAAKoG,WAAW,EAAKD,QAAQH,SACtB,EAAK0B,MAAM,kBAAmB,WAAW,KApFxD,KAuFAA,MAAQ,SAAC9B,EAAS+B,EAAYC,GAE1B,OACI,EAAKvB,SAAST,EAAS,CACnB+B,WAAYA,EACZC,YAAaA,KA5FzB,KA+FAT,yBAA2B,SAACL,EAAkBC,GAC1C,IAAI,IAAIjH,EAAI,EAAGA,EAAI,EAAKqG,QAAQnG,OAAQF,IAEb,UAApB,EAAKqG,QAAQrG,KAEZ,EAAKqG,QAAQrG,GAAK,QAG1B,EAAKqG,QAAQW,GAAoB,SACjC,EAAKX,QAAQY,GAAkB,iBAC/B,EAAKX,WAAW,EAAKD,QAAQH,UAxG7BpC,KAAK6C,eAAiB,GACtB7C,KAAKuC,QAAUA,EAAQH,QACvBpC,KAAKwC,WAAaA,EAClBxC,KAAKyC,SAAWA,GC4TTwB,EAxTD,SAAClI,GA4RX,IA3RA,IAAMmI,EAAa,2CADE,EAIiBzG,mBAAS,CAAC,8FACQ,iEACA,kDACI,oDACI,0DACI,gGAEA,mKAX/C,mBAIhBwD,EAJgB,KAIFE,EAJE,OAcS1D,oBAAS,GAdlB,mBAcdF,EAdc,KAcLW,EAdK,OAemBT,oBAAS,GAf5B,mBAedD,EAfc,KAeAc,EAfA,KAgBf6F,EAASpI,EAAMqI,eACfC,EAAQtI,EAAMqI,eACdE,EAAOvI,EAAMqI,eAAiBrI,EAAMqI,eAlBrB,EAmBS3G,oBAAS,GAnBlB,mBAmBdd,EAnBc,KAmBL0E,EAnBK,OAoB6B5D,mBAAS,IApBtC,mBAoBdyD,EApBc,KAoBKE,EApBL,OAqBmB3D,mBAASC,MAAM4G,GAAM3G,MAAK,IArB7C,mBAqBd4G,EArBc,KAqBAC,EArBA,OAsBS/G,mBAASC,MAAM4G,GAAM3G,KAAK,SAtBnC,mBAsBd4E,EAtBc,KAsBLC,EAtBK,OAuBS/E,mBAASC,MAAM4G,GAAM3G,KAAK,IAvBnC,mBAuBd8G,EAvBc,KAuBLC,EAvBK,OAwB2BjH,oBAAU,GAxBrC,mBAwBdyF,EAxBc,KAwBIyB,EAxBJ,OAyBuBlH,oBAAU,GAzBjC,oBAyBd0F,GAzBc,MAyBEyB,GAzBF,MA2BdnC,GAAYoC,sBAAZpC,SACDqC,GAAkB,IAAI9D,EAAgBC,EAAcC,EAAmBC,EAAiBC,EAAsBC,GAC9G0D,GAAgB,IAAIzC,EAAeC,EAASC,EAAYC,IAGxDuC,GCXwC,SAACd,EAAYI,EAAMD,EAAO/C,EAAiBmB,GAA3C,8CAE9C,WAAQwC,EAAW/B,EAAkBC,EAAgBoB,EAAcE,EAASS,GAA5E,SAAAC,EAAA,sEACUC,IAAMC,KAAKnB,EAAce,EAAW,CAAC/B,mBAAkBC,iBAAgBmB,OAAMD,QAAOE,eAAcE,YAE/Fa,MAAK,SAAAC,GACF,IAAMhE,EAAQ,IAAIG,KAElB,GADAJ,EAAgBC,EAAOgE,EAAI/D,KAAK,IACZ,OAAhB+D,EAAI/D,KAAK,GAGT,OAAQiB,EAAS,sBAAuB,CAACsB,WAAY,UAAWC,aAAa,IAF7EkB,EAAQK,EAAI/D,KAAK,GAAI0B,EAAkBC,MAI9CqC,OAAM,SAAAC,GACH3F,QAAQ4F,MAAMD,MAZ9B,2CAF8C,gEDWtBE,CAAmCzB,EAAYI,EAAMD,EAAOS,GAAgBxD,gBAAiBmB,IAC/GmD,GCnC0C,SAAC1B,EAAYI,EAAMD,EAAOF,EAAQ7C,EAAiBmB,EAAU+B,EAAiBhC,GAA9E,8CAEhD,WAAOyC,EAAW/B,EAAkBC,EAAgBZ,EAASgC,EAAcE,GAA3E,SAAAU,EAAA,sEAEUC,IAAMC,KAAKnB,EAAae,EAAW,CAAC/B,mBAAkBC,iBAAgBmB,OAAMD,QAAOF,SAAQ5B,UAASgC,eAAcE,YAC3Ha,MAAK,SAAAC,GACF,IAAMhE,EAAQ,IAAIG,KAClBJ,EAAgBC,EAAOgE,EAAI/D,KAAK,IAGhC,IAFA,IAAIyB,EAAMsC,EAAI/D,KAAK,GACfqE,EAAmBnI,MAAM4G,GAAM3G,MAAK,GAChCzB,EAAI,EAAGA,EAAI+G,EAAI7G,OAAQF,IAEb,UAAX+G,EAAI/G,KACH2J,EAAiB3J,IAAK,GAE9BsI,EAAgBqB,GAChBrD,EAAW+C,EAAI/D,KAAK,OAEvBgE,OAAM,SAAAC,GAAQ3F,QAAQ4F,MAAMD,MAhB7B,2CAFgD,gEDmCvBK,CAAoC5B,EAAYI,EAAMD,EAAOF,EAAQW,GAAgBxD,gBAAiBmB,EAAU+B,EAAiBhC,GA4BpJtD,GAAiB,uCAAG,sBAAAiG,EAAA,sDAEtBL,GAAgB/C,uBAAuB,2CAA2C,GAClF6D,GAAiB,oBAAqB1C,EAAkBC,GAAgBZ,EAASgC,EAAcE,GAASa,MAAK,SAAAS,GAAC,OAAIjG,QAAQC,SAHpG,2CAAH,qDAUjBiG,GAAuB,WACzB,OAAI9C,EAAmB,GAAKC,GAAiB,EAGrCV,GAAS,qDAAsD,CAC3DsB,WAAY,UACZC,aAAa,IAGlB,MAELiC,GAA0B,SAACC,EAAcC,EAAO1F,EAAO2F,GAEzD,IAAMrI,EAAOwE,EAAQH,QAClBgE,GACCC,GAA8BtI,GAC9BmI,GAAc,IAGdA,EAAaC,GAEjBpI,EAAKoI,GAAS1F,EACd+B,EAAWzE,IAYXuI,GAAY,SAACpK,GACb,IAAIqK,EAAe,GACnB,IAAGhC,EAAarI,GAAhB,CAEA,IAAIqB,EAAJ,CAGO,GAAI2F,IAAqBhH,EAC5B+J,GAAwBtB,EAAqBzI,EAAG,QAAQ,GACxDqK,EAAe,iCACZ,GAAIrD,EAAmB,GAAKC,KAAmBjH,EAClD+J,GAAwBrB,GAAmB1I,EAAG,QAAQ,GACtDqK,EAAe,+BACZ,GAAIrD,EAAmB,EAC1B+C,GAAwBtB,EAAqBzI,EAAG,UAAU,GAC1DqK,EAAe,+BACZ,GAAIpD,KAAmBjH,EAC1B+J,GAAwBrB,GAAmB1I,EAAG,QAAQ,GACtDqK,EAAe,8BACZ,MAAIpD,GAAiB,GAIxB,OAHA8C,GAAwBrB,GAAmB1I,EAAG,kBAAkB,GAChEqK,EAAe,wBAInB,OAAQ9D,GAAS8D,EAAc,CAACxC,WAAY,OAAQC,aAAa,KAlC5C,SAAC9H,GAEtB,IAAM2J,EAAmBtB,EAAanC,QAChCoE,EAAcjE,EAAQH,QAC5ByD,EAAiB3J,IAAK,EACtBsI,EAAgBqB,GAChBW,EAAYtK,GAAK,QACjBsG,EAAWgE,EAAYpE,SAOnBqE,CAAiBvK,KAyBnBmK,GAAgC,SAACtI,GACnC,IAAI,IAAI7B,EAAI,EAAGA,EAAIqG,EAAQnG,OAAQF,IACf,UAAZ6B,EAAK7B,IAAkBA,IAAMgH,GAAoBhH,IAAMiH,KACvDpF,EAAK7B,GAAK,QAKlB,OAFA6B,EAAKmF,GAAoB,SACzBnF,EAAKoF,IAAkB,iBAChBpF,GASLuB,GAAe,WACjBoF,EAAWhH,MAAM4G,GAAM3G,KAAK,KAE1ByB,GAAa,WAtBXoD,EAAW9E,MAAM4G,GAAM3G,KAAK,SAahC6G,EAAgB9G,MAAM4G,GAAM3G,MAAK,IAGjCgH,GAAqB,GACrBC,IAAmB,GASnBtF,MAGED,GAAgB,uCAAG,4BAAA8F,EAAA,6DAEjB5D,EAAQ,IAAIG,KAChBL,GAAW,GACXyD,GAAgB7C,mBAChB6C,GAAgBhD,eAAe,4CAA6C,YALvD,SAMfsD,IAAMC,KAAKnB,EAAa,mBAAoB,CAACI,SAC9CgB,MAAK,SAAAC,GACFlE,GAAW,GACXyD,GAAgBxD,gBAAgBC,EAAOgE,EAAI/D,KAAK,IAChDkD,EAAWa,EAAI/D,KAAK,OAVP,2CAAH,qDAchBjC,GAAiB,uCAAG,8BAAA4F,EAAA,6DAGrBL,GAAgB/C,uBAAuB,+CAAgDV,GACvFuD,IAAmB,GACnBD,GAAqB,GACjBpD,EAAQ,IAAIG,KAChBL,GAAW,GACXyD,GAAgB7C,mBAChB7C,KACA0F,GAAgBhD,eAAe,mCAAoC,YAC7D4E,EAAQ9E,KAAK+E,MAAM/E,KAAKgF,SAAWhF,KAAK+E,MAAMrC,IACrDxE,QAAQC,IAAI2G,GAZU,UAaftB,IAAMC,KAAKnB,EAAa,YAAa,CAACwC,QAAOpC,OAAMD,QAAOE,iBAC3De,MAAK,SAAAC,GAEFZ,EAAoB+B,GACpBrF,GAAW,GACXyD,GAAgBxD,gBAAgBC,EAAOgE,EAAI/D,KAAK,IA0B/C,IAzBD,IAAMqF,EAAUtB,EAAI/D,KAAK,GAAG,GAKtBsF,GAJUvB,EAAI/D,KAAK,GAAG,GACF+D,EAAI/D,KAAK,GAAG,GAClB+D,EAAI/D,KAAK,GAAG,GACR+D,EAAI/D,KAAK,GAAG,GACf+D,EAAI/D,KAAK,GAAG,IAE3BuF,GADmBxB,EAAI/D,KAAK,GAAG,GACZ+D,EAAI/D,KAAK,GAAG,IACjCqE,EAAmBnI,MAAM4G,GAAM3G,MAAK,GAClC6I,EAAcjE,EAAQH,QACtB4E,EAAcvC,EAAQrC,QAenBlG,EAAI,EAAGA,EAAI2K,EAAQzK,OAAQF,IAE/BsK,EAAYK,EAAQ3K,IAAM,OAC1BuI,EAAQoC,EAAQ3K,IAAM,SAiB3B,IAAI,IAAIA,EAAI,EAAGA,EAAIuI,EAAQrI,OAAQF,KAEA,IAA5B6K,EAAiB7K,GAAG,GAEW,MAA3B6K,EAAiB7K,GAAG,IAEnB8K,EAAY9K,GAAK,GACjBsK,EAAYtK,GAAK,QACjB2J,EAAiB3J,IAAK,IAGtB8K,EAAY9K,GAAK6K,EAAiB7K,GAAG,GACrCsK,EAAYtK,GAAK,QAKrB8K,EAAY9K,GAAK4K,EAAa5K,GAGtCsK,EAAYE,GAAS,SACrBhC,EAAWsC,EAAY5E,SACvBI,EAAWgE,EAAYpE,SACvBoC,EAAgBqB,EAAiBzD,YAEpCoD,OAAM,SAAAC,GAAQ3F,QAAQ4F,MAAMD,MAzFZ,4CAAH,qDA+FnBwB,GAAe,SAACC,GAChB,OAAQ,kBAAC,EAAD,CAAQnK,GAAIwF,EAAQ2E,GAAQf,MAAOe,EAAOvH,OAAU8E,EAAQyC,GAAQlK,QAASmK,GAAKjK,U,EAAWgK,GAAQ1K,IAAK0K,KAElHC,GAAO,SAACjL,GACLsB,EAjNW,SAAC0J,GACfzC,EAAQyC,GAASzC,EAAQyC,GAAO,EAChCxC,EAAWD,EAAQrC,SAgNfgF,CAAUlL,GAEVoK,GAAUpK,IAIdmL,GAAS,GACTH,GAAQ,EACHhL,GAAI,EAAGA,GAAImI,EAAOnI,KAAK,CAE5B,IADA,IAAIoL,GAAW,GACNC,GAAI,EAAGA,GAAIpD,EAAQoD,KACxBD,GAASjL,KAAK4K,GAAaC,KAC3BA,KAEJG,GAAOhL,KAAK,yBAAKG,IAAKN,GAAGU,UAAW,aAAc0K,KAEtD,IAAME,GAAwB,CAACzI,wBAzPC,WAEE,OAA3BiH,OACClB,GAAgB/C,uBAAuB,wBACvCiD,GAAgB,mBAAoB9B,EAAkBC,GAAgBoB,EAAcE,EAASM,GAAc/B,0BAA0BsC,MAAK,SAAAS,GAAC,OAAIjG,QAAQC,IAAI,WAqPlFf,yBAlPhD,WACC,OAA3BgH,OACClB,GAAgB/C,uBAAuB,wBACvCiD,GAAgB,oBAAqB9B,EAAkBC,GAAgBoB,EAAcE,EAASM,GAAcrB,uBAAuB4B,MAAK,SAAAS,GAAC,OAAIjG,QAAQC,IAAI,WA+O5Bd,gBAhQ/G,WAEY,OAA3B+G,OACClB,GAAgB/C,uBAAuB,6BACvCiD,GAAgB,WAAY9B,EAAkBC,GAAgBoB,EAAcE,EAASM,GAAcrB,uBAAuB4B,MAAK,SAAAS,GAAC,OAAIjG,QAAQC,IAAI,YA6PpJb,kBAAmBA,GAAmBC,kBA5OhB,WACtB2F,GAAgB/C,uBAAuB,2DAA2D,GAClG6D,GAAiB,uBAAwB1C,EAAkBC,GAAgBZ,EAASgC,EAAcE,GAASa,MAAK,SAAAS,GAAC,OAAIjG,QAAQC,UA2O7HX,WAAYA,GAAYC,iBAAkBA,GAAkBC,aAAcA,GAC1EC,kBAAmBA,GAAmBhC,QAASA,EAASW,WAAYA,EAAYV,aAAcA,EAAcc,gBAAiBA,GAEjI,OACI,yBAAKvB,GAAI,OACL,yBAAKA,GAAI,WACL,kBAAC,EAAD,CAAMO,WAAckK,MAExB,yBAAKzK,GAAI,aACJsK,GACD,yBAAKtK,GAAI,YACL,kBAAC,EAAD,CAAQJ,QAAWA,EAASM,cAAiB6H,GAAgBzC,kBAAkBnF,U,GAAYf,SAAY8E,EAAcxE,OAAUyE,QErT7IuG,E,kDACF,WAAY1L,GACX,IAAD,8BACI,cAAMA,IACD0D,MAAQ,CAET2E,eAAiB,IAJzB,E,qDAQI,OAEI,yBAAKrH,GAAI,OAAOH,UAAU,QAEtB,yBAAKA,UAAU,cACX,kBAAC,gBAAD,CAAeG,GAAM,SAAU2K,mBAAoB,IAAMC,UAAU,iBAC/D,kBAAC,EAAD,CAAO5K,GAAI,QAASqH,eAAkBpE,KAAKP,MAAM2E,wB,GAhBtDtD,IAAMC,WAyBzB6G,IAASC,OACL,kBAAC,EAAD,MAGA1J,SAASC,eAAe,W","file":"static/js/main.ed1bc4e9.chunk.js","sourcesContent":["import Card from \"react-bootstrap/Card\";\nimport Button from \"react-bootstrap/Button\";\nimport React from \"react\";\nimport RingLoader from \"react-spinners/RingLoader\"\n\nconst MyCard = (props) =>\n{\n    const holder = [];\n    for(let i = 0; i < props.messages.length; i++)\n    {//values will not be sorted or changed in any way such that using the index for the key should be fine\n        holder.push( <Card.Title key = {\"Title\" + i} >{props.header[i]}</Card.Title>)\n        holder.push(  <Card.Text key = {\"Message\" + i}>{props.messages[i]}</Card.Text>)\n    }\n    let loader\n    if(props.loading)\n    {\n        loader =  <div className = \"sweet-loading\">\n            <RingLoader\n            />\n        </div>\n    }\n    return (\n    <Card className=\"text-center\">\n        <Card.Header>\n            <Button id={\"headerButton\"} onClick = {props.clearMessages.bind(this)}>Clear Messages</Button>\n            Messages Sent and Received\n\n        </Card.Header>\n        <Card.Body>\n            {loader}\n            {holder}\n        </Card.Body>\n    </Card>)\n}\nexport default MyCard","import Button from \"react-bootstrap/Button\";\nimport React, {useState} from \"react\";\n\n\nconst Menu = (props) =>\n{\n    let barrierButton = props.dictionary.barrier\n    let weightButton = props.dictionary.weightButton\n    const [dropDownMenu, setDropDownMenu] = useState(Array(2).fill(false))\n    const toggleOpen = (i) =>\n    {\n        const temp = [false, false]\n        temp[i] = !dropDownMenu[i]\n        setDropDownMenu(temp)\n    }\n    const createBarrier = () => {\n        if(weightButton)\n            setWeightButtonFunction()\n        barrierButton = !barrierButton\n        props.dictionary.setBarrier(barrierButton)\n        if (barrierButton)\n            document.getElementById(\"barrier\").innerText = \"Disable Barrier\"\n        else\n            document.getElementById(\"barrier\").innerText = \"Draw Barrier\"\n    }\n    const setWeightButtonFunction = () =>\n    {\n        if(barrierButton)\n            createBarrier()\n        weightButton = !weightButton\n        props.dictionary.setWeightButton(weightButton)\n        if(weightButton)\n            document.getElementById(\"addWeights\").innerText = \"Toggle Weights Off\"\n        else\n            document.getElementById(\"addWeights\").innerText = \"Set Weights\"\n    }\n    const menuClass1 = `dropdown-menu ${ dropDownMenu[0]? \" show\": \"\"}`\n    const menuClass2 = `dropdown-menu ${ dropDownMenu[1]? \" show\": \"\"}`\n    return(\n            <div id = \"buttons1\" className = \"btn-group-vertical\" role={\"group\"}>\n                <div className=\"btn-group\" role=\"group\">\n                    <button id=\"btnGroupDrop\" type=\"button\"  onClick = {toggleOpen.bind(this, 0)} className=\"btn btn-primary dropdown-toggle\"\n                            data-toggle=\"dropdown-menu\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                        Shortest Path Algorithms\n                    </button>\n                    <div className={menuClass1} aria-labelledby=\"btnGroupDrop1\">\n                        <a id={\"menuButton\"} className = \"btn btn-primary-controlButton\" onClick = { props.dictionary.backendDepthFirstSearch.bind(this) }>\n                            Depth First Search\n                            <p> (Does path Exist)</p>\n                        </a>\n                        <a id={\"menuButton\"} className = \"btn btn-primary-controlButton\" onClick = { props.dictionary.backendBreathFirstSearch.bind(this) }>\n                            Breath-First Search\n                            <p>(Shortest Path)</p>\n                        </a>\n                        <a id={\"menuButton\"} className = \"btn btn-primary-controlButton\" onClick = { props.dictionary.backendDijkstra.bind(this) }>\n                            Dijkstra's SPF\n                        </a>\n                    </div>\n                </div>\n                <div className=\"btn-group\" role=\"group\">\n                    <button id=\"btnGroupDrop\" type=\"button\"  onClick = {toggleOpen.bind(this, 1)} className=\"btn btn-primary dropdown-toggle\"\n                            data-toggle=\"dropdown-menu\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                        Maze Generation Algorithms\n                    </button>\n                    <div className={menuClass2} aria-labelledby=\"btnGroupDrop11\">\n                        <a id={\"menuButton\"} className = \"btn btn-primary-controlButton1\" onClick = { props.dictionary.generatePrimsMaze.bind(this) }>\n                            Prim's Maze\n                        </a>\n                        <a id={\"menuButton\"} className = \"btn btn-primary-controlButton1\" onClick = { props.dictionary.generateBacktrack.bind(this) }>\n                            Recursive Backtracking\n                        </a>\n\n                    </div>\n                </div>\n                <Button className = \"btn btn-lg btn-primary-controlButton\" onClick = {props.dictionary.clearGraph.bind(this)}>Clear Graph</Button>\n                <Button className = \"btn btn-lg btn-primary-controlButton\"  id = \"barrier\" onClick = { createBarrier.bind(this)}>Draw Barrier</Button>\n                <Button className = \"btn btn-lg btn-primary-controlButton\" id =\"addWeights\" onClick = { setWeightButtonFunction.bind(this) }>Set Weights</Button>\n                <Button className = \"btn btn-lg btn-primary-controlButton\" id =\"randomizeWeights\" onClick = { props.dictionary.randomizeWeights.bind(this)}>Randomize Weights</Button>\n                <Button className = \"btn btn-lg btn-primary-controlButton\" id = \"randomizeWeights\" onClick = { props.dictionary.clearWeights.bind(this)}>Remove Weights</Button>\n                <Button className = \"btn btn-lg btn-primary-controlButton\" id = \"randomizeWeights\" onClick = { props.dictionary.generatePrimsTree.bind(this)}>Create Randomized Minimum Spanning Tree (not finished)</Button>\n            </div>\n    )\n}\n\nexport default Menu","import React from \"react\";\nimport Button from \"react-bootstrap/Button\";\nclass Square extends React.Component {\n    constructor(props) {\n        super(props)\n        this.state = {\n            hover: false,\n            id: 'grey',\n            weight: 0\n        }\n        this.onMouseEnterSquare = this.onMouseEnterSquare.bind(this)\n        this.onMouseLeaveSquare = this.onMouseLeaveSquare.bind(this)\n        this.onClick = this.onClick.bind(this)\n    }\n\n    onMouseEnterSquare() {\n        console.log(\"this is id: \"  + this.props.id)\n        if(this.props.id === 'black')\n            return\n        this.setState({\n            id: 'red',\n            hover: true\n        })\n    }\n\n    onMouseLeaveSquare() {\n        this.setState({\n            id: 'blue',\n            hover: false\n        })\n    }\n    onClick() {\n        this.props.onClick()\n    }\n    shouldComponentUpdate(nextProps, nextState, nextContext)\n    {\n        return (nextState.id !== this.state.id || this.props.weight !== nextProps.weight || this.props.id !== nextProps.id)\n    }\n    render() {\n        let stateId\n        let textColor = 'white'\n        if(!this.state.hover)\n            stateId = this.props.id\n        else\n            stateId = this.state.id\n        if(stateId === 'white' || stateId === 'black')\n            textColor = 'black'\n        const divStyle = {\n            background: stateId,\n            color: textColor\n        }\n        return (\n            <Button\n                variant=\"secondary\"\n                className=\"square\"\n                style = {divStyle}\n                onMouseEnter={this.onMouseEnterSquare.bind()}\n                onMouseLeave={this.onMouseLeaveSquare.bind()}\n                onClick={this.onClick.bind()}>\n                {this.props.weight}\n            </Button>\n        )\n    }\n}\n\nexport default Square\n\n","/*******************************************/\n/*\nMethods for Card messages and responses\n */\nclass MessagesForCard {\n    constructor(cardMessages, backendOrFrontEnd, setCardMessages, setBackEndOrFrontEnd, setLoading)\n    {\n        this.setLoading = setLoading\n        this.cardMessages = cardMessages\n        this.backendOrFrontEnd = backendOrFrontEnd\n        this.setCardMessages = setCardMessages\n        this.setBackEndOrFrontEnd = setBackEndOrFrontEnd\n    }\n    backendResponse = (date1, data) => {\n        this.setLoading(false)\n        const date2 = new Date()\n        const time = Math.abs(date2 - date1)\n        this.updateMessages(data, 'Backend')\n        this.updateMessages('Query round trip time: ' + time + \" milliseconds\", 'Frontend')\n    }\n\n    frontendInitialMessage = (message) => {\n        this.setLoading(true)\n        this.messageSeparator()\n        this.updateMessages(message, 'Frontend')\n    }\n    messageSeparator = () => {\n        this.updateMessages(\" \", \" *************************  \")\n    }\n    updateMessages = (data, sender) => {\n        this.cardMessages.unshift(data)\n        this.backendOrFrontEnd.unshift(sender)\n        this.setCardMessages(this.cardMessages.slice())\n        this.setBackEndOrFrontEnd(this.backendOrFrontEnd.slice())\n    }\n    clearCardMessages = () => {\n        this.setCardMessages([])\n        this.setBackEndOrFrontEnd([])\n    }\n}\nexport default MessagesForCard","\nclass animateMethods{\n    constructor(squares, setSquares, addToast)\n    {\n        this.animationTrail = 10\n        this.squares = squares.slice()\n        this.setSquares = setSquares\n        this.addToast = addToast\n    }\n    animateTrail = (tickIndex, tickArr) =>\n    {\n        this.squares[tickArr[tickIndex]] = 'maroon'\n        if(tickIndex > this.animationTrail)\n            this.squares[tickArr[tickIndex-this.animationTrail]] = 'green'\n    }\n    finishAnimationTrail = (current, tickArr, tickIndex) =>\n    {\n        this.squares[tickArr[tickIndex-current]] = 'green'\n        current--\n        this.setSquares(this.squares.slice())\n        return current\n    }\n    animateWithoutReturnPath = (arr, startMarkerIndex, endMarkerIndex) => {\n        let tickIndex = 1\n        let current = this.animationTrail\n        const timerID2 = setInterval(() => tick2(arr), 10)\n        this.resetBoardOnAlgorithmRun(startMarkerIndex, endMarkerIndex)\n        const tick2 = (tickArr) => {\n            if (tickIndex < tickArr.length - 1) {\n            //mutating the array directly :/\n                this.animateTrail(tickIndex, tickArr)\n                tickIndex++\n                this.setSquares(this.squares.slice())\n            } else {\n                if (current > 0)\n                    current = this.finishAnimationTrail(current, tickArr, tickIndex)\n                else\n                {\n                    clearInterval(timerID2)\n                    this.returnToast(tickArr)\n                }\n            }\n        }\n    }\n    animateWithReturnPath = (arr, startMarkerIndex, endMarkerIndex) => {\n        const findPathArr = arr[0]\n        const shortestPathArr = arr[1]\n        const timerID2 = setInterval(() => tick2(findPathArr, shortestPathArr), 10)\n        let tickIndex = 0\n        this.resetBoardOnAlgorithmRun(startMarkerIndex, endMarkerIndex)\n        let finishedAnimatingFindPath = false\n        const tick2 = (findPathArr, shortestPathArr) => {\n            if (!finishedAnimatingFindPath) {\n                if (tickIndex <= findPathArr.length) {\n                    for (let i = 0; i < 4; i++) {\n                        //mutating the array directly -- doesn't seem to update promptly otherwise\n                        if (tickIndex <= findPathArr.length && findPathArr[tickIndex] !== endMarkerIndex && findPathArr[tickIndex] !== startMarkerIndex) {\n                            this.squares[findPathArr[tickIndex]] = 'green'\n                        }\n                        tickIndex++\n                    }\n                } else {\n                    finishedAnimatingFindPath = true\n                    this.squares[endMarkerIndex] = 'gold'\n                    tickIndex = 0\n                }\n                this.setSquares(this.squares.slice())\n            } else {\n                if (tickIndex < shortestPathArr.length - 1) {\n                    this.squares[shortestPathArr[tickIndex]] = 'gold'\n                    this.setSquares(this.squares.slice())\n                    tickIndex++\n                } else {\n                    this.squares[shortestPathArr[shortestPathArr.length - 1]] = 'gold'\n                    this.setSquares(this.squares.slice())\n                    clearInterval(timerID2)\n                }\n            }\n        }\n    }\n    returnToast = (tickArr) =>\n    {\n        if (tickArr[tickArr.length - 1] === false) {\n            return this.toast(\"Path does not exist\", 'warning', true)\n        } else {\n            this.squares[tickArr[tickArr.length - 1]] = 'gold'\n            this.setSquares(this.squares.slice())\n            return this.toast(\"Path does exist\", 'success', true)\n        }\n    }\n    toast = (message, appearance, autoDismiss) =>\n    {\n        return (\n            this.addToast(message, {\n                appearance: appearance,\n                autoDismiss: autoDismiss,\n            }))\n    }\n    resetBoardOnAlgorithmRun = (startMarkerIndex, endMarkerIndex) =>{\n        for(let i = 0; i < this.squares.length; i++)\n        {\n            if(this.squares[i] !== 'black')\n            {\n                this.squares[i] = 'grey'\n            }\n        }\n        this.squares[startMarkerIndex] = 'orange'\n        this.squares[endMarkerIndex] = 'cornflowerblue'\n        this.setSquares(this.squares.slice())\n    }\n}\nexport default animateMethods","import React, {useState} from \"react\";\nimport MyCard from \"./CustomCard\"\nimport Menu from \"./Menu\"\nimport {useToasts} from \"react-toast-notifications\";\nimport Square from \"./Square\"\nimport axios from \"axios\"\nimport MessagesForCard from \"./MessagesForCard\"\nimport animateMethods from \"./animateMethods\"\nimport {queryBackendHigherOrderFunctionSPF, queryBackendHigherOrderFunctionMaze} from \"./QueryBackend\"\n\n\nconst Board = (props) => {\n    const testingUrl = \"https://visualizerbackend.herokuapp.com/\"\n    //const testingUrl = \"http://localhost:9000/\"\n    //can likely optimize blockedNodes\n    let [cardMessages, setCardMessages] = useState([\"Note: If the server has been idle, the initial query may take up to 10 seconds to complete.\",\n                                                            \"Backend is hosted at: https://visualizerbackend.herokuapp.com/\",\n                                                            \"To use:  Click a square to set a start location\",\n                                                                \"Then click another square to select a destination\",\n                                                                    \"You may also set barriers to change the available paths\",\n                                                                        \"For Dijkstra's SPF you can set the weight of each square \" +\n                                                                        \"changing the algorithm's chosen path\",\n                                                                        \"As a note: The path found may not be the 'straightest' path as diagonal moves are valid,\" +\n                                                                        \"but if you count the squares it will be equal to a more intuitive path\"])\n\n    const [barrier, setBarrier] = useState(false)\n    const [weightButton, setWeightButton] = useState(false)\n    const HEIGHT = props.heightAndWidth\n    const WIDTH = props.heightAndWidth\n    const SIZE = props.heightAndWidth * props.heightAndWidth\n    const [loading, setLoading] = useState(false)\n    const [backendOrFrontEnd, setBackEndOrFrontEnd] = useState([])\n    const [blockedNodes, setBlockedNodes] = useState(Array(SIZE).fill(false))\n    const [squares, setSquares] = useState(Array(SIZE).fill('grey'))\n    const [weights, setWeights] = useState(Array(SIZE).fill(1))\n    const [startMarkerIndex, setStartMarkerIndex] = useState(-1)\n    const [endMarkerIndex, setEndMarkerIndex] = useState(-1)\n\n    const {addToast} = useToasts()\n    const messagesForCard = new MessagesForCard(cardMessages, backendOrFrontEnd, setCardMessages, setBackEndOrFrontEnd, setLoading)\n    const animateMethod = new animateMethods(squares, setSquares, addToast)\n   /********************************************/\n    //Higher order function to make querying the backend more concise and easier\n    const queryBackendSPF = queryBackendHigherOrderFunctionSPF(testingUrl, SIZE, WIDTH, messagesForCard.backendResponse, addToast)\n    const queryBackendMaze = queryBackendHigherOrderFunctionMaze(testingUrl, SIZE, WIDTH, HEIGHT, messagesForCard.backendResponse, addToast, setBlockedNodes, setSquares)\n   /******************************************/\n    /* Methods for SPF algorithms */\n    let backendDijkstra = () =>\n    {\n        if(checkForValidMarkers() === null) {\n            messagesForCard.frontendInitialMessage('Sending data for Dijkstra')\n            queryBackendSPF('dijkstra', startMarkerIndex, endMarkerIndex, blockedNodes, weights, animateMethod.animateWithReturnPath).then(r => console.log(\"hey\"))\n        }\n    }\n    const backendDepthFirstSearch = () =>\n    {\n        if(checkForValidMarkers() === null) {\n            messagesForCard.frontendInitialMessage('Sending data for DFS')\n            queryBackendSPF('depthFirstSearch', startMarkerIndex, endMarkerIndex, blockedNodes, weights, animateMethod.animateWithoutReturnPath).then(r => console.log(\"ok\"))\n        }\n    }\n    const backendBreathFirstSearch = () => {\n        if(checkForValidMarkers() === null) {\n            messagesForCard.frontendInitialMessage(\"Sending data for BFS\")\n            queryBackendSPF('breathFirstSearch', startMarkerIndex, endMarkerIndex, blockedNodes, weights, animateMethod.animateWithReturnPath).then(r => console.log(\"ok\"))\n        }\n    }\n    // MAZES\n    const generateBacktrack = () => {\n        messagesForCard.frontendInitialMessage('Sending data for Recursive Backtracking Maze Generation', false)\n        queryBackendMaze('generateBacktracking', startMarkerIndex, endMarkerIndex, squares, blockedNodes, weights).then(r => console.log())\n    }\n    const generatePrimsMaze = async () =>\n    {\n        messagesForCard.frontendInitialMessage(\"Sending data for Prim's Maze Generation\", false)\n        queryBackendMaze('generatePrimsMaze', startMarkerIndex, endMarkerIndex, squares, blockedNodes, weights).then(r => console.log())\n    }\n    const setWeight = (count) => {\n        weights[count] = weights[count]+1\n        setWeights(weights.slice())\n    }\n\n    const checkForValidMarkers = () => {\n        if((startMarkerIndex < 0 || endMarkerIndex < 0))\n        {\n            return (\n                addToast(\"Please select a starting and ending location first\", {\n                    appearance: 'warning',\n                    autoDismiss: true,\n                }))\n        }\n        return null\n    }\n    const setStartAndEndLocations = (markerMethod, index, color, deselected) =>\n    {\n        const temp = squares.slice()\n        if(deselected) {\n            resetBoardOnDestinationChange(temp)\n            markerMethod(-1)\n        }\n        else {\n            markerMethod(index)\n        }\n        temp[index] = color\n        setSquares(temp)\n    }\n\n    const setNodeToBlocked = (i) =>\n    {\n        const tempBlockedNodes = blockedNodes.slice()\n        const tempSquares = squares.slice()\n        tempBlockedNodes[i] = true\n        setBlockedNodes(tempBlockedNodes)\n        tempSquares[i] = 'black'\n        setSquares(tempSquares.slice())\n    }\n    let setMarker = (i) => {\n        let toastMessage = \"\"\n        if(blockedNodes[i]) //is already a blocked node.  Nothing to do with those\n            return\n        if (barrier) { //manually setting barrier\n            setNodeToBlocked(i)\n            return\n        } else if (startMarkerIndex === i) {\n            setStartAndEndLocations(setStartMarkerIndex, i, 'grey', true)\n            toastMessage = 'Deselected Start Location'\n        } else if (startMarkerIndex < 0 && endMarkerIndex === i) {\n            setStartAndEndLocations(setEndMarkerIndex, i, 'grey', true)\n            toastMessage = 'Deselected End Location'\n        } else if (startMarkerIndex < 0) {\n            setStartAndEndLocations(setStartMarkerIndex, i, 'orange', false)\n            toastMessage = \"Start Location Selected\"\n        } else if (endMarkerIndex === i) {\n            setStartAndEndLocations(setEndMarkerIndex, i, 'grey', true)\n            toastMessage = \"Deselected End Location\"\n        } else if (endMarkerIndex < 0) {\n            setStartAndEndLocations(setEndMarkerIndex, i, 'cornflowerblue', false)\n            toastMessage = 'Selected End Location'\n        } else {\n            return\n        }\n        return (addToast(toastMessage, {appearance: 'info', autoDismiss: true,}))\n    }\n    const clearSquares = () => {\n            setSquares(Array(SIZE).fill('grey'))\n    }\n    const resetBoardOnDestinationChange = (temp) =>{\n        for(let i = 0; i < squares.length; i++) {\n            if (temp[i] !== 'black' && i !== startMarkerIndex && i !== endMarkerIndex) {\n                temp[i] = 'grey'\n            }\n        }\n        temp[startMarkerIndex] = 'orange'\n        temp[endMarkerIndex] = 'cornflowerblue'\n        return temp\n    }\n    const clearBarrier = () => {\n        setBlockedNodes(Array(SIZE).fill(false))\n    }\n    const clearMarkers = () => {\n        setStartMarkerIndex(-1)\n        setEndMarkerIndex(-1)\n    }\n    const clearWeights = () => {\n        setWeights(Array(SIZE).fill(1))\n    }\n    const clearGraph = () => {\n        clearSquares()\n        clearBarrier()\n        clearMarkers()\n        clearWeights()\n    }\n\n    const randomizeWeights = async () =>\n    {\n        let date1 = new Date()\n        setLoading(true)\n        messagesForCard.messageSeparator()\n        messagesForCard.updateMessages('Sending data for random weight generation', 'Frontend')\n        await axios.post(testingUrl + 'weightGeneration', {SIZE})\n            .then(res => {\n                setLoading(false)\n                messagesForCard.backendResponse(date1, res.data[0])\n                setWeights(res.data[1])\n            })\n    }\n    /**** WIP *********/\n    const generatePrimsTree = async () => {\n       // if (checkForValidMarkers(false) !== null)\n        //    return\n         messagesForCard.frontendInitialMessage(\"Sending data for Prims Minimum Spanning Tree\", setLoading)\n         setEndMarkerIndex(-1)\n         setStartMarkerIndex(-1)\n         let date1 = new Date()\n         setLoading(true)\n         messagesForCard.messageSeparator()\n         clearGraph()\n         messagesForCard.updateMessages('Sending data for maze generation', 'Frontend')\n         const start = Math.floor(Math.random() * Math.floor(SIZE))\n        console.log(start)\n         await axios.post(testingUrl + 'primsTree', {start, SIZE, WIDTH, blockedNodes})\n             .then(res => {\n\n                 setStartMarkerIndex(start)\n                 setLoading(false)\n                 messagesForCard.backendResponse(date1, res.data[0])\n                 const nodeArr = res.data[1][0]\n                 const edgeArr = res.data[1][1]\n                 const initialWeightList = res.data[1][2]\n                 const endNodeList = res.data[1][3]\n                 const visitedNodeList = res.data[1][4]\n                 const finalWeights = res.data[1][5]\n                 const orderOfTraversal = res.data[1][6]\n                 const directionOfEdges = res.data[1][7]\n                 let tempBlockedNodes = Array(SIZE).fill(false)\n                 const tempSquares = squares.slice()\n                 const tempWeights = weights.slice()\n\n                 ///WORK ON tRYING TO ANIMATE ORDER OF TRAVERSAL\n\n\n\n                 /*const sleep = (milliseconds) => {\n                     const date = Date.now();\n                     let currentDate = null;\n                     do {\n                         currentDate = Date.now();\n                     } while (currentDate - date < milliseconds);\n                 }*/\n\n                 //FOR INITIAL SETUP DONT ERASE\n                  for(let i = 0; i < nodeArr.length; i++)\n                  {\n                      tempSquares[nodeArr[i]] = 'grey'\n                      weights[nodeArr[i]] = '\\u221E'\n                  }\n\n                  //setStartMarkerIndex(-1)\n                 //if(squares[endMarkerIndex]  !== 'white')\n                  //   squares[endMarkerIndex] = 'grey'\n                  //setEndMarkerIndex(-1)\n                  //squares[startMarkerIndex] = 'orange'\n                  //squares[endMarkerIndex] = 'cornflowerblue'\n                  //setBlockedNodes(tempBlockedNodes)\n                 // setSquares(squares.slice())\n                 // setWeights(initialWeightList)\n\n               // sleep(5000)\n                 //FINAL RESULT\n                 //console.log(\"after sleep\")\n\n                 for(let i = 0; i < weights.length; i++)\n                 {\n                     if(directionOfEdges[i][0] !== -1)\n                     {\n                         if(directionOfEdges[i][1] === \"F\")\n                         {\n                             tempWeights[i] = \"\"\n                             tempSquares[i] = 'black'\n                             tempBlockedNodes[i] = true\n                         }\n                         else {\n                             tempWeights[i] = directionOfEdges[i][1]\n                             tempSquares[i] = 'grey'\n                         }\n                     }\n                     else\n                     {\n                         tempWeights[i] = finalWeights[i]\n                     }\n                 }\n                 tempSquares[start] = 'orange'\n                 setWeights(tempWeights.slice())\n                 setSquares(tempSquares.slice())\n                 setBlockedNodes(tempBlockedNodes.slice())\n             })\n             .catch(err => {console.error(err)})\n\n    }\n    /**************************************/\n    /* methods to control menus */\n\n    let renderSquare = (count) => {\n        return (<Square id={squares[count]} index={count} weight = {weights[count]} onClick={fork.bind(this, count)} key={count}/>)\n    }\n    let fork = (i) => {\n        if(weightButton)\n            setWeight(i)\n        else\n            setMarker(i)\n    }\n    /***************************************/\n    /* everything below is to render the board*/\n    let parent = []\n    let count = 0\n    for (let i = 0; i < WIDTH; i++) {\n        let children = []\n        for (let j = 0; j < HEIGHT; j++) {\n            children.push(renderSquare(count))\n            count++\n        }\n        parent.push(<div key={i} className={\"board-row\"}>{children}</div>)\n    }\n    const menuDictionaryMethods = {backendDepthFirstSearch: backendDepthFirstSearch, backendBreathFirstSearch: backendBreathFirstSearch, backendDijkstra: backendDijkstra,\n        generatePrimsMaze: generatePrimsMaze, generateBacktrack: generateBacktrack,\n        clearGraph: clearGraph, randomizeWeights: randomizeWeights, clearWeights: clearWeights,\n        generatePrimsTree: generatePrimsTree, barrier: barrier, setBarrier: setBarrier, weightButton: weightButton, setWeightButton: setWeightButton}\n\n    return (\n        <div id={\"box\"}>\n            <div id={\"leftBox\"}>\n                <Menu dictionary = {menuDictionaryMethods}/>\n            </div>\n            <div id={\"centerBox\"}>\n                {parent}\n                <div id={\"rightBox\"}>\n                    <MyCard loading = {loading} clearMessages = {messagesForCard.clearCardMessages.bind(this)} messages = {cardMessages} header = {backendOrFrontEnd} />\n                </div>\n            </div>\n        </div>\n    );\n}\n\nexport default Board","import axios from \"axios\";\n/*\ncreates a function that returns a function that is responsible for messaging the backend,\nanimating the return values\nor\nresponding that there are no return values to animate\n */\n\n\nexport const queryBackendHigherOrderFunctionMaze =  (testingUrl, SIZE, WIDTH, HEIGHT, backendResponse, addToast, setBlockedNodes, setSquares) =>\n\n    async (urlSuffix, startMarkerIndex, endMarkerIndex, squares, blockedNodes, weights) =>\n    {\n        await axios.post(testingUrl + urlSuffix, {startMarkerIndex, endMarkerIndex, SIZE, WIDTH, HEIGHT, squares, blockedNodes, weights })\n    .then(res=>{\n        const date1 = new Date()\n        backendResponse(date1, res.data[0])\n        let arr = res.data[1]\n        let tempBlockedNodes = Array(SIZE).fill(false)\n        for(let i = 0; i < arr.length; i++)\n        {\n            if(arr[i] === 'black')\n                tempBlockedNodes[i] = true\n        }\n        setBlockedNodes(tempBlockedNodes)\n        setSquares(res.data[1])\n    })\n    .catch(err => {console.error(err)})\n    }\n\n\n\nexport const queryBackendHigherOrderFunctionSPF = (testingUrl, SIZE, WIDTH, backendResponse, addToast) =>\n\n    async  (urlSuffix, startMarkerIndex, endMarkerIndex, blockedNodes, weights, animate) => {\n        await axios.post(testingUrl  + urlSuffix, {startMarkerIndex, endMarkerIndex, SIZE, WIDTH, blockedNodes, weights\n            })\n                .then(res => {\n                    const date1 = new Date()\n                    backendResponse(date1, res.data[0])\n                    if (res.data[1] !== null )\n                        animate(res.data[1], startMarkerIndex, endMarkerIndex)\n                    else\n                        return (addToast(\"Path does not exist\", {appearance: 'warning', autoDismiss: true,}))\n                })\n                .catch(err => {\n                    console.error(err)\n                })\n        }\n\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport 'bootstrap/dist/css/bootstrap.css'\nimport Board from './Board.js'\nimport {ToastProvider} from \"react-toast-notifications\";\n\nclass Game extends React.Component {\n    constructor(props)\n    {\n        super(props)\n        this.state =({\n            //must be square\n            heightAndWidth : 40,\n        })\n    }\n    render() {\n        return (\n\n            <div id =\"body\" className=\"game\">\n\n                <div className=\"game-board\">\n                    <ToastProvider id = {\"toasty\"} autoDismissTimeout={2000} placement=\"bottom-center\">\n                        <Board id={\"board\"} heightAndWidth = {this.state.heightAndWidth}/>\n                    </ToastProvider>\n                </div>\n            </div>\n\n        );\n    }\n}\n\nReactDOM.render(\n    <Game />,\n\n\n    document.getElementById('root')\n);\n\n\n"],"sourceRoot":""}