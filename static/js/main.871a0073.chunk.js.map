{"version":3,"sources":["CustomCard.js","Square.js","Board.js","QueryBackend.js","index.js"],"names":["MyCard","props","loader","holder","i","messages","length","push","Card","Title","key","header","Text","loading","className","Header","Button","id","onClick","clearMessages","bind","Body","Square","state","hover","weight","onMouseEnterSquare","onMouseLeaveSquare","console","log","this","setState","nextProps","nextState","nextContext","stateId","textColor","divStyle","background","color","variant","style","onMouseEnter","onMouseLeave","React","Component","Board","testingUrl","useState","cardMessages","setCardMessages","HEIGHT","heightAndWidth","WIDTH","SIZE","setLoading","backendOrFrontEnd","setBackEndOrFrontEnd","Array","fill","blockedNodes","setBlockedNodes","squares","setSquares","weights","setWeights","startMarkerIndex","setStartMarkerIndex","dropDownMenu","setDropDownMenu","endMarkerIndex","setEndMarkerIndex","barrier","setBarrier","addToast","useToasts","weightButton","setWeightButton","backendResponse","date1","data","date2","Date","time","Math","abs","updateMessages","frontendInitialMessage","message","caller","checkForValidMarkers","messageSeparator","sender","unshift","slice","queryBackendSPF","urlSuffix","animate","a","axios","post","then","res","appearance","autoDismiss","catch","err","error","queryBackendHigherOrderFunctionSPF","queryBackendMaze","arr","tempBlockedNodes","queryBackendHigherOrderFunctionMaze","generatePrimsMaze","r","animateWithoutReturnPath","tickIndex","current","timerID2","setInterval","tick2","resetBoardOnAlgorithmRun","tickArr","animateTrail","finishAnimationTrail","clearInterval","returnToast","animateWithReturnPath","findPathArr","shortestPathArr","finishedAnimatingFindPath","resetBoardOnDestinationChange","clearWeights","createBarrier","setWeightButtonFunction","document","getElementById","innerText","randomizeWeights","generatePrimsTree","value","nodeArr","visitedNodeList","finalWeights","directionOfEdges","renderSquare","count","index","fork","setWeight","toastMessage","startStateMarker","endStateMarker","SetMarker","toggleOpen","temp","menuClass1","menuClass2","parent","children","j","role","type","data-toggle","aria-haspopup","aria-expanded","aria-labelledby","clearSquares","Game","autoDismissTimeout","placement","ReactDOM","render"],"mappings":"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","file":"static/js/main.871a0073.chunk.js","sourcesContent":["import Card from \"react-bootstrap/Card\";\nimport Button from \"react-bootstrap/Button\";\nimport React from \"react\";\nimport RingLoader from \"react-spinners/RingLoader\"\n\nconst MyCard = (props) =>\n{\n    const holder = [];\n    for(let i = 0; i < props.messages.length; i++)\n    {//values will not be sorted or changed in any way such that using the index for the key should be fine\n        holder.push( <Card.Title key = {\"Title\" + i} >{props.header[i]}</Card.Title>)\n        holder.push(  <Card.Text key = {\"Message\" + i}>{props.messages[i]}</Card.Text>)\n    }\n    let loader\n    if(props.loading)\n    {\n        loader =  <div className = \"sweet-loading\">\n            <RingLoader\n            />\n        </div>\n    }\n    return (\n    <Card className=\"text-center\">\n        <Card.Header>\n            <Button id={\"headerButton\"} onClick = {props.clearMessages.bind(this)}>Clear Messages</Button>\n            Messages Sent and Received\n\n        </Card.Header>\n        <Card.Body>\n            {loader}\n            {holder}\n        </Card.Body>\n    </Card>)\n}\nexport default MyCard","import React from \"react\";\nimport Button from \"react-bootstrap/Button\";\nclass Square extends React.Component {\n    constructor(props) {\n        super(props)\n        this.state = {\n            hover: false,\n            id: 'grey',\n            weight: 0\n        }\n        this.onMouseEnterSquare = this.onMouseEnterSquare.bind(this)\n        this.onMouseLeaveSquare = this.onMouseLeaveSquare.bind(this)\n        this.onClick = this.onClick.bind(this)\n    }\n\n    onMouseEnterSquare() {\n        console.log(\"this is id: \"  + this.props.id)\n        if(this.props.id === 'black')\n            return\n        this.setState({\n            id: 'red',\n            hover: true\n        })\n    }\n\n    onMouseLeaveSquare() {\n        this.setState({\n            id: 'blue',\n            hover: false\n        })\n    }\n    onClick() {\n        this.props.onClick()\n    }\n    shouldComponentUpdate(nextProps, nextState, nextContext)\n    {\n        return (nextState.id !== this.state.id || this.props.weight !== nextProps.weight || this.props.id !== nextProps.id)\n    }\n    render() {\n        let stateId\n        let textColor = 'white'\n        if(!this.state.hover)\n            stateId = this.props.id\n        else\n            stateId = this.state.id\n        if(stateId === 'white' || stateId === 'black')\n            textColor = 'black'\n        const divStyle = {\n            background: stateId,\n            color: textColor\n        }\n        return (\n            <Button\n                variant=\"secondary\"\n                className=\"square\"\n                style = {divStyle}\n                onMouseEnter={this.onMouseEnterSquare.bind()}\n                onMouseLeave={this.onMouseLeaveSquare.bind()}\n                onClick={this.onClick.bind()}>\n                {this.props.weight}\n            </Button>\n        )\n    }\n}\n\nexport default Square\n\n","import React, {useState} from \"react\";\nimport MyCard from \"./CustomCard\"\nimport {useToasts} from \"react-toast-notifications\";\nimport Button from \"react-bootstrap/Button\";\nimport Square from \"./Square\"\nimport axios from \"axios\"\nimport {queryBackendHigherOrderFunctionSPF, queryBackendHigherOrderFunctionMaze} from \"./QueryBackend\"\n\n\nconst Board = (props) => {\n    //const testingUrl = \"https://visualizerbackend.herokuapp.com/\"\n    const testingUrl = \"http://localhost:9000/\"\n    //can likely optimize blockedNodes\n    let [cardMessages, setCardMessages] = useState([\"Note: If the server has been idle, the initial query may take up to 10 seconds to complete.\",\n                                                            \"Backend is hosted at: https://visualizerbackend.herokuapp.com/\",\n                                                            \"To use:  Click a square to set a start location\",\n                                                                \"Then click another square to select a destination\",\n                                                                    \"You may also set barriers to change the available paths\",\n                                                                        \"For Dijkstra's SPF you can set the weight of each square \" +\n                                                                        \"changing the algorithm's chosen path\",\n                                                                        \"As a note: The path found may not be the 'straightest' path as diagonal moves are valid,\" +\n                                                                        \"but if you count the squares it will be equal to a more intuitive path\"])\n    const animationTrail = 10\n    const HEIGHT = props.heightAndWidth\n    const WIDTH = props.heightAndWidth\n    const SIZE = props.heightAndWidth * props.heightAndWidth\n    const [loading, setLoading] = useState(false)\n    let [backendOrFrontEnd, setBackEndOrFrontEnd] = useState([])\n    const [blockedNodes, setBlockedNodes] = useState(Array(SIZE).fill(false))\n    let [squares, setSquares] = useState(Array(SIZE).fill('grey'))\n    let [weights, setWeights] = useState(Array(SIZE).fill(1))\n    const [startMarkerIndex, setStartMarkerIndex] = useState(-1)\n    const [dropDownMenu, setDropDownMenu] = useState(Array(2).fill(false))\n    const [endMarkerIndex, setEndMarkerIndex] = useState(-1)\n    const [barrier, setBarrier] = useState(false)\n    const {addToast} = useToasts()\n    const [weightButton, setWeightButton] = useState(false)\n\n/*******************************************/\n    /*\n    Methods for Card messages and responses\n     */\n    const backendResponse = (date1, data) =>\n    {\n        setLoading(false)\n        const date2 = new Date()\n        const time = Math.abs(date2-date1)\n        updateMessages(data, 'Backend'  )\n        updateMessages('Query round trip time: ' +  time + \" milliseconds\", 'Frontend')\n    }\n    const frontendInitialMessage = (message, caller) =>\n    {\n        if(caller === true)\n            if(checkForValidMarkers())\n                return\n        setLoading(true)\n        messageSeparator()\n        updateMessages(message, 'Frontend')\n        return null\n    }\n    const messageSeparator = () =>\n    {\n        updateMessages(\" \", \" *************************  \")\n    }\n\n    const updateMessages = (data, sender) =>\n    {\n        cardMessages.unshift(data)\n        backendOrFrontEnd.unshift(sender)\n        setCardMessages(cardMessages.slice())\n        setBackEndOrFrontEnd(backendOrFrontEnd.slice())\n\n    }\n    const clearCardMessages = () =>\n    {\n        setCardMessages([])\n        setBackEndOrFrontEnd([])\n    }\n    /*********************************************/\n    //Higher order function to make querying the backend more concise and easier\n    const queryBackendSPF = queryBackendHigherOrderFunctionSPF(testingUrl, SIZE, WIDTH, backendResponse, addToast)\n    const queryBackendMaze = queryBackendHigherOrderFunctionMaze(testingUrl, SIZE, WIDTH, HEIGHT, backendResponse, addToast, setBlockedNodes, setSquares)\n   /******************************************/\n    /* Methods for SPF algorithms */\n    let backendDijkstra = () =>\n    {\n        const value = frontendInitialMessage('Sending data for Dijkstra', true)\n        if(value !== null) return value\n        queryBackendSPF('dijkstra', startMarkerIndex, endMarkerIndex, blockedNodes, weights, animateWithReturnPath).then(r => console.log(\"hey\"))\n    }\n    const backendDepthFirstSearch = () =>\n    {\n        const value = frontendInitialMessage('Sending data for DFS', true)\n        if(value !== null) return value\n        queryBackendSPF('depthFirstSearch', startMarkerIndex, endMarkerIndex, blockedNodes, weights, animateWithoutReturnPath).then(r => console.log(\"ok\"))\n    }\n\n    const backendBreathFirstSearch = () => {\n        const value = frontendInitialMessage(\"Sending data for BFS\", true)\n        if(value !== null) return value\n\n        queryBackendSPF('breathFirstSearch', startMarkerIndex, endMarkerIndex, blockedNodes, weights, animateWithReturnPath).then(r => console.log(\"ok\"))\n    }\n    // MAZES\n    const generateBacktrack = () => {\n        frontendInitialMessage('Sending data for Recursive Backtracking Maze Generation', false)\n        queryBackendMaze('generateBacktracking', startMarkerIndex, endMarkerIndex, squares, blockedNodes, weights).then(r => console.log())\n    }\n\n    const generatePrimsMaze = async () =>\n    {\n        frontendInitialMessage(\"Sending data for Prim's Maze Generation\", false)\n        queryBackendMaze('generatePrimsMaze', startMarkerIndex, endMarkerIndex, squares, blockedNodes, weights).then(r => console.log())\n    }\n    /********************************************************/\n    const animateTrail = (tickIndex, tickArr) =>\n    {\n        squares[tickArr[tickIndex]] = 'maroon'\n        if(tickIndex > animationTrail)\n        {\n            squares[tickArr[tickIndex-animationTrail]] = 'green'\n        }\n    }\n    const finishAnimationTrail = (current, tickArr, tickIndex) =>\n    {\n        squares[tickArr[tickIndex-current]] = 'green'\n        current--\n        setSquares(squares.slice())\n        return current\n    }\n    const returnToast = (tickArr) =>\n    {\n        if (tickArr[tickArr.length - 1] === false) {\n            return (\n                addToast(\"Path does not exist\", {\n                    appearance: 'warning',\n                    autoDismiss: true,\n                }))\n        } else {\n            squares[tickArr[tickArr.length - 1]] = 'gold'\n            setSquares(squares.slice())\n            return (\n                addToast(\"Path does exist\", {\n                    appearance: 'success',\n                    autoDismiss: true,\n                }))\n        }\n    }\n    const animateWithoutReturnPath = (arr) => {\n        let tickIndex = 1\n        let current = animationTrail\n        const timerID2 = setInterval(() => tick2(arr), 10)\n        resetBoardOnAlgorithmRun()\n        const tick2 = (tickArr) => {\n            if (tickIndex < tickArr.length - 1) {\n                //mutating the array directly :/\n                animateTrail(tickIndex, tickArr)\n                tickIndex++\n                setSquares(squares.slice())\n            } else {\n                if (current > 0)\n                    current = finishAnimationTrail(current, tickArr, tickIndex)\n                else\n                {\n                    clearInterval(timerID2)\n                    returnToast(tickArr)\n                }\n            }\n        }\n\n    }\n    let animateWithReturnPath = (arr) => {\n        const findPathArr = arr[0]\n        const shortestPathArr = arr[1]\n        const timerID2 = setInterval(() => tick2(findPathArr, shortestPathArr), 10)\n        let tickIndex = 0\n        resetBoardOnAlgorithmRun()\n        let finishedAnimatingFindPath = false\n        const tick2 = (findPathArr, shortestPathArr) =>\n        {\n            if(!finishedAnimatingFindPath)\n            {\n                if (tickIndex <= findPathArr.length) {\n                    for(let i = 0; i < 4; i++)\n                    {\n                        //mutating the array directly -- doesn't seem to update promptly otherwise\n                        if (tickIndex <= findPathArr.length && findPathArr[tickIndex] !== endMarkerIndex && findPathArr[tickIndex] !== startMarkerIndex)\n                        {\n                            squares[findPathArr[tickIndex]] = 'green'\n                        }\n                        tickIndex++\n                    }\n                }\n                else\n                {\n                    finishedAnimatingFindPath = true\n                    squares[endMarkerIndex] = 'gold'\n                    tickIndex = 0\n                }\n                setSquares(squares.slice())\n            }\n            else\n            {\n                if(tickIndex < shortestPathArr.length - 1)\n                {\n                    squares[shortestPathArr[tickIndex]] = 'gold'\n                    setSquares(squares.slice())\n                    tickIndex++\n                }\n                else{\n                    squares[shortestPathArr[shortestPathArr.length - 1]] = 'gold'\n                    setSquares(squares.slice())\n                    clearInterval(timerID2)\n                }\n            }\n        }\n    }\n\n    const setWeight = (count) => {\n        weights[count] = weights[count]+1\n        setWeights(weights.slice())\n    }\n\n    const checkForValidMarkers = () => {\n        if (startMarkerIndex < 0 || endMarkerIndex < 0) {\n            return (\n                addToast(\"Please select a starting and ending location first\", {\n                    appearance: 'warning',\n                    autoDismiss: true,\n                }))\n        } else return null\n    }\n\n\n    let SetMarker = (i) => {\n        let toastMessage = \"\"\n        let startStateMarker = startMarkerIndex;\n        let endStateMarker = endMarkerIndex;\n        if(blockedNodes[i]) //is already a blocked node.  Nothing to do with those\n        {\n            return\n        }\n        if (barrier) { //manually setting barrier\n            blockedNodes[i] = true\n            setBlockedNodes(blockedNodes.slice())\n            squares[i] = 'black'\n            setSquares(squares.slice())\n            return\n        } else if (startStateMarker === i) {\n            squares[i] = 'grey'\n            startStateMarker = -1\n            toastMessage = \"Deselected Start Location\"\n            resetBoardOnDestinationChange()\n        } else if (startStateMarker < 0 && endStateMarker === i) {\n            endStateMarker = -1\n            squares[i] = 'grey'\n            resetBoardOnDestinationChange()\n            toastMessage = \"Deselected End Location\"\n        } else if (startStateMarker < 0) {\n            startStateMarker = i\n            squares[i] = 'orange'\n            toastMessage = \"Start Location Selected\"\n        } else if (endStateMarker === i) {\n            squares[i] = 'grey'\n            endStateMarker = -1\n            resetBoardOnDestinationChange()\n            toastMessage = \"Deselected End Location\"\n        } else if (endStateMarker < 0) {\n            endStateMarker = i\n            squares[i] = 'cornflowerblue'\n            toastMessage = \"Selected End Location\"\n        } else {\n            return\n        }\n        setStartMarkerIndex(startStateMarker)\n        setEndMarkerIndex(endStateMarker)\n        squares[startStateMarker] = 'orange'\n        squares[endStateMarker] = 'cornflowerblue'\n        setSquares(squares.slice())\n        return (\n            addToast(toastMessage, {\n                appearance: 'info',\n                autoDismiss: true,\n            }))\n    }\n\n    const clearSquares = () => {\n        //squares not changing without setting squares explicitly\n        for(let i = 0; i < squares.length; i++) {\n            squares = Array(SIZE).fill(null)\n            setSquares(Array(SIZE).fill(null))\n        }\n    }\n    const resetBoardOnDestinationChange = () =>{\n        for(let i = 0; i < squares.length; i++) {\n            if (squares[i] === 'green' || squares[i] === 'gold') {\n                squares[i] = 'grey'\n            }\n        }\n        setSquares(squares.slice())\n    }\n    const resetBoardOnAlgorithmRun = () =>{\n        for(let i = 0; i < squares.length; i++) {\n            if (squares[i] === 'green' || squares[i] === 'gold') {\n                squares[i] = 'grey'\n            }\n        }\n        squares[startMarkerIndex] = 'startMarker'\n        squares[endMarkerIndex] = 'endMarker'\n        setSquares(squares.slice())\n    }\n    const clearBarrier = () => {\n        setBlockedNodes(Array(SIZE).fill(false))\n    }\n    const clearMarkers = () => {\n        setStartMarkerIndex(-1)\n        setEndMarkerIndex(-1)\n    }\n    const clearWeights = () => {\n        setWeights(Array(SIZE).fill(1))\n    }\n    const clearGraph = () => {\n        clearSquares()\n        clearBarrier()\n        clearMarkers()\n        clearWeights()\n    }\n    const createBarrier = () => {\n        setBarrier(!barrier)\n        if(weightButton)\n        {\n            setWeightButtonFunction()\n        }\n        if (barrier)\n            document.getElementById(\"barrier\").innerText = \"Draw Barrier\"\n        else\n            document.getElementById(\"barrier\").innerText = \"Disable Barrier\"\n    }\n\n    const setWeightButtonFunction = () =>\n    {\n        setWeightButton(!weightButton)\n        if(barrier)\n        {\n            createBarrier()\n        }\n        if(weightButton)\n            document.getElementById(\"addWeights\").innerText = \"Set Weights\"\n        else\n            document.getElementById(\"addWeights\").innerText = \"Toggle Weights Off\"\n\n    }\n    const randomizeWeights = async () =>\n    {\n        let date1 = new Date()\n        setLoading(true)\n        messageSeparator()\n        updateMessages('Sending data for random weight generation', 'Frontend')\n        await axios.post(testingUrl + 'weightGeneration', {SIZE})\n            .then(res => {\n                setLoading(false)\n                backendResponse(date1, res.data[0])\n                setWeights(res.data[1])\n            })\n    }\n\n    const generatePrimsTree = async () =>\n    {\n        const value = frontendInitialMessage(\"Sending data for Prims Minimum Spanning Tree\", true)\n        if(value !== null) return value\n         let date1 = new Date()\n         setLoading(true)\n         messageSeparator()\n         updateMessages('Sending data for maze generation', 'Frontend')\n         await axios.post(testingUrl + 'primsTree', {startMarkerIndex, SIZE, WIDTH, blockedNodes, weights })\n             .then(res => {\n                 setLoading(false)\n                 backendResponse(date1, res.data[0])\n                 const nodeArr = res.data[1][0]\n                 const edgeArr = res.data[1][1]\n                 const initialWeightList = res.data[1][2]\n                 const endNodeList = res.data[1][3]\n                 const visitedNodeList = res.data[1][4]\n                 const finalWeights = res.data[1][5]\n                 const orderOfTraversal = res.data[1][6]\n                 const directionOfEdges = res.data[1][7]\n                 let tempBlockedNodes = Array(SIZE).fill(false)\n\n                 ///WORK ON tRYING TO ANIMATE ORDER OF TRAVERSAL\n\n\n\n                 const sleep = (milliseconds) => {\n                     const date = Date.now();\n                     let currentDate = null;\n                     do {\n                         currentDate = Date.now();\n                     } while (currentDate - date < milliseconds);\n                 }\n\n                 //FOR INITIAL SETUP DONT ERASE\n                  for(let i = 0; i < nodeArr.length; i++)\n                  {\n                      squares[nodeArr[i]] = 'white'\n                      weights[nodeArr[i]] = '\\u221E'\n                  }\n                  setStartMarkerIndex(-1)\n                 if(squares[endMarkerIndex]  !== 'white')\n                     squares[endMarkerIndex] = 'grey'\n                  setEndMarkerIndex(-1)\n                  //squares[startMarkerIndex] = 'orange'\n                  //squares[endMarkerIndex] = 'cornflowerblue'\n                  //setBlockedNodes(tempBlockedNodes)\n                 // setSquares(squares.slice())\n                 // setWeights(initialWeightList)\n\n               // sleep(5000)\n                 //FINAL RESULT\n                 console.log(\"after sleep\")\n\n                 for(let i = 0; i < weights.length; i++)\n                 {\n                     if(directionOfEdges[i][0] !== -1)\n                     {\n                         weights[i] = directionOfEdges[i][1]\n                     }\n                     else\n                         weights[i] = finalWeights[i]\n                 }\n                 setWeights(weights.slice())\n                 setSquares(squares.slice())\n                 console.log(visitedNodeList)\n\n             })\n             .catch(err => {console.error(err)})\n    }\n\n    /**************************************/\n    /* methods to control menus */\n\n    let renderSquare = (count) => {\n        return (<Square id={squares[count]} index={count} weight = {weights[count]} onClick={fork.bind(this, count)} key={count}/>)\n    }\n    let fork = (i) => {\n        if(weightButton)\n            setWeight(i)\n        else\n            SetMarker(i)\n    }\n    const toggleOpen = (i) =>\n    {\n        const temp = [false, false]\n        temp[i] = !dropDownMenu[i]\n        setDropDownMenu(temp)\n    }\n    const menuClass1 = `dropdown-menu ${ dropDownMenu[0]? \" show\": \"\"}`\n    const menuClass2 = `dropdown-menu ${ dropDownMenu[1]? \" show\": \"\"}`\n\n    /***************************************/\n    /* everything below is to render the board*/\n    let parent = []\n    let count = 0\n    for (let i = 0; i < WIDTH; i++) {\n        let children = []\n        for (let j = 0; j < HEIGHT; j++) {\n            children.push(renderSquare(count))\n            count++\n        }\n        parent.push(<div key={i} className={\"board-row\"}>{children}</div>)\n    }\n\n    return (\n        <div id={\"box\"}>\n            <div id={\"leftBox\"}>\n                    <div id = \"buttons1\" className = \"btn-group-vertical\" role={\"group\"}>\n                        <div className=\"btn-group\" role=\"group\">\n                            <button id=\"btnGroupDrop\" type=\"button\"  onClick = {toggleOpen.bind(this, 0)} className=\"btn btn-primary dropdown-toggle\"\n                                data-toggle=\"dropdown-menu\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                                Shortest Path Algorithms\n                            </button>\n                            <div className={menuClass1} aria-labelledby=\"btnGroupDrop1\">\n                                <a id={\"menuButton\"} className = \"btn btn-primary-controlButton\" onClick = { backendDepthFirstSearch.bind(this) }>\n                                    Depth First Search\n                                    <p> (Does path Exist)</p>\n                                </a>\n                                <a id={\"menuButton\"} className = \"btn btn-primary-controlButton\" onClick = { backendBreathFirstSearch.bind(this) }>\n                                    Breath-First Search\n                                    <p>(Shortest Path)</p>\n                                </a>\n                                <a id={\"menuButton\"} className = \"btn btn-primary-controlButton\" onClick = { backendDijkstra.bind(this) }>\n                                    Dijkstra's SPF\n                                </a>\n                            </div>\n                        </div>\n                        <div className=\"btn-group\" role=\"group\">\n                            <button id=\"btnGroupDrop\" type=\"button\"  onClick = {toggleOpen.bind(this, 1)} className=\"btn btn-primary dropdown-toggle\"\n                                    data-toggle=\"dropdown-menu\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                                Maze Generation Algorithms\n                            </button>\n                            <div className={menuClass2} aria-labelledby=\"btnGroupDrop11\">\n                                <a id={\"menuButton\"} className = \"btn btn-primary-controlButton1\" onClick = { generatePrimsMaze.bind(this) }>\n                                    Prim's Maze\n                                </a>\n                                <a id={\"menuButton\"} className = \"btn btn-primary-controlButton1\" onClick = { generateBacktrack.bind(this) }>\n                                    Recursive Backtracking\n                                </a>\n\n                            </div>\n                        </div>\n                    <Button className = \"btn btn-lg btn-primary-controlButton\" onClick = {clearGraph.bind(this)}>Clear Graph</Button>\n                    <Button className = \"btn btn-lg btn-primary-controlButton\"  id = \"barrier\" onClick = { createBarrier.bind(this)}>Draw Barrier</Button>\n                    <Button className = \"btn btn-lg btn-primary-controlButton\" id =\"addWeights\" onClick = { setWeightButtonFunction.bind(this) }>Set Weights</Button>\n                        <Button className = \"btn btn-lg btn-primary-controlButton\" id =\"randomizeWeights\" onClick = { randomizeWeights.bind(this)}>Randomize Weights</Button>\n                    <Button className = \"btn btn-lg btn-primary-controlButton\" id = \"randomizeWeights\" onClick = { clearWeights.bind(this)}>Remove Weights</Button>\n                           <Button className = \"btn btn-lg btn-primary-controlButton\" id = \"randomizeWeights\" onClick = { generatePrimsTree.bind(this)}>Create Randomized Directed Acyclic Graph (DAG) (not finished)</Button>\n                    </div>\n            </div>\n            <div id={\"centerBox\"}>\n                {parent}\n                <div id={\"rightBox\"}>\n                    <MyCard loading = {loading} clearMessages = {clearCardMessages.bind(this)} messages = {cardMessages} header = {backendOrFrontEnd} />\n\n                </div>\n            </div>\n\n\n        </div>\n    );\n}\n\nexport default Board\n\n\n/*\n\n */","import axios from \"axios\";\n/*\ncreates a function that returns a function that is responsible for messaging the backend,\nanimating the return values\nor\nresponding that there are no return values to animate\n */\n\n\nexport const queryBackendHigherOrderFunctionMaze =  (testingUrl, SIZE, WIDTH, HEIGHT, backendResponse, addToast, setBlockedNodes, setSquares) =>\n\n    async (urlSuffix, startMarkerIndex, endMarkerIndex, squares, blockedNodes, weights) =>\n    {\n\n    await axios.post(testingUrl + urlSuffix, {startMarkerIndex, endMarkerIndex, SIZE, WIDTH, HEIGHT, squares, blockedNodes, weights })\n    .then(res=>{\n        const date1 = new Date()\n        backendResponse(date1, res.data[0])\n        let arr = res.data[1]\n        let tempBlockedNodes = Array(SIZE).fill(false)\n        for(let i = 0; i < arr.length; i++)\n        {\n            if(arr[i] === 'black')\n                tempBlockedNodes[i] = true\n        }\n        setBlockedNodes(tempBlockedNodes)\n        setSquares(res.data[1])\n    })\n    .catch(err => {console.error(err)})\n    }\n\n\n\n\n\nexport const queryBackendHigherOrderFunctionSPF =  (testingUrl, SIZE, WIDTH, backendResponse, addToast) =>\n\n    async  (urlSuffix, startMarkerIndex, endMarkerIndex, blockedNodes, weights, animate) => {\n\n            await axios.post(testingUrl  + urlSuffix, {startMarkerIndex, endMarkerIndex, SIZE, WIDTH, blockedNodes, weights\n            })\n                .then(res => {\n                    const date1 = new Date()\n                    backendResponse(date1, res.data[0])\n                    if (res.data[1] !== null ) {\n                        animate(res.data[1])\n                    } else\n                        return (\n                            addToast(\"Path does not exist\", {\n                                appearance: 'warning',\n                                autoDismiss: true,\n                            }))\n                })\n                .catch(err => {\n                    console.error(err)\n                })\n        }\n\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport 'bootstrap/dist/css/bootstrap.css'\nimport Board from './Board.js'\nimport {ToastProvider} from \"react-toast-notifications\";\n\nclass Game extends React.Component {\n    constructor(props)\n    {\n        super(props)\n        this.state =({\n            //must be square\n            heightAndWidth : 40,\n        })\n    }\n    render() {\n        return (\n\n            <div id =\"body\" className=\"game\">\n\n                <div className=\"game-board\">\n                    <ToastProvider id = {\"toasty\"} autoDismissTimeout={2000} placement=\"bottom-center\">\n                        <Board id={\"board\"} heightAndWidth = {this.state.heightAndWidth}/>\n                    </ToastProvider>\n                </div>\n            </div>\n\n        );\n    }\n}\n\nReactDOM.render(\n    <Game />,\n\n\n    document.getElementById('root')\n);\n\n\n"],"sourceRoot":""}