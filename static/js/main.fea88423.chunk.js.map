{"version":3,"sources":["CustomCard.js","Square.js","Board.js","index.js"],"names":["MyCard","props","loader","holder","i","messages","length","push","Card","Title","key","header","Text","loading","className","Header","Button","id","onClick","clearMessages","bind","Body","Square","state","hover","weight","onMouseEnterSquare","onMouseLeaveSquare","console","log","this","setState","nextProps","nextState","nextContext","stateId","variant","onMouseEnter","onMouseLeave","React","Component","Board","testingUrl","useState","cardMessages","setCardMessages","HEIGHT","heightAndWidth","WIDTH","SIZE","setLoading","backendOrFrontEnd","setBackEndOrFrontEnd","Array","fill","blockedNodes","setBlockedNodes","squares","setSquares","weights","setWeights","startMarkerIndex","setStartMarkerIndex","dropDownMenu","setDropDownMenu","endMarkerIndex","setEndMarkerIndex","barrier","setBarrier","addToast","useToasts","weightButton","setWeightButton","updateMessages","data","sender","unshift","slice","dialogToOutput","date1","date2","Date","time","Math","abs","backendDijkstra","a","valid","checkForValidMarkers","messageSeparator","axios","post","then","res","appearance","autoDismiss","animateWithReturnPath","catch","err","error","backendDepthFirstSearch","animateWithoutReturnPath","backendBreathFirstSearch","arr","timerID2","tickIndex","resetRun","tick2","tickArr","clearInterval","setInterval","findPathArr","shortestPathArr","finishedAnimatingFindPath","renderSquare","count","index","fork","setWeight","SetMarker","toastMessage","startStateMarker","endStateMarker","clearWeights","createBarrier","setWeightButtonFunction","document","getElementById","innerText","randomizeWeights","generateBacktrack","tempBlockedNodes","generatePrimsTree","generatePrimsMaze","parent","children","j","toggleOpen","temp","menuClass1","menuClass2","role","type","data-toggle","aria-haspopup","aria-expanded","aria-labelledby","clearSquares","Game","autoDismissTimeout","placement","ReactDOM","render"],"mappings":"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","file":"static/js/main.fea88423.chunk.js","sourcesContent":["import Card from \"react-bootstrap/Card\";\nimport Button from \"react-bootstrap/Button\";\nimport React from \"react\";\nimport RingLoader from \"react-spinners/RingLoader\"\n\nconst MyCard = (props) =>\n{\n    const holder = [];\n    for(let i = 0; i < props.messages.length; i++)\n    {//values will not be sorted or changed in any way such that using the index for the key should be fine\n        holder.push( <Card.Title key = {\"Title\" + i} >{props.header[i]}</Card.Title>)\n        holder.push(  <Card.Text key = {\"Message\" + i}>{props.messages[i]}</Card.Text>)\n    }\n    let loader\n    if(props.loading)\n    {\n        loader =  <div className = \"sweet-loading\">\n            <RingLoader\n            />\n        </div>\n    }\n    return (\n    <Card className=\"text-center\">\n        <Card.Header>\n            <Button id={\"headerButton\"} onClick = {props.clearMessages.bind(this)}>Clear Messages</Button>\n            Messages Sent and Received\n\n        </Card.Header>\n        <Card.Body>\n            {loader}\n            {holder}\n        </Card.Body>\n    </Card>)\n}\nexport default MyCard","import React from \"react\";\nimport Button from \"react-bootstrap/Button\";\nclass Square extends React.Component {\n    constructor(props) {\n        super(props)\n        this.state = {\n            hover: false,\n            id: 'grey',\n            weight: 0\n        }\n        this.onMouseEnterSquare = this.onMouseEnterSquare.bind(this)\n        this.onMouseLeaveSquare = this.onMouseLeaveSquare.bind(this)\n        this.onClick = this.onClick.bind(this)\n    }\n\n    onMouseEnterSquare() {\n        console.log(\"this is id: \"  + this.props.id)\n        if(this.props.id === 'black')\n            return\n        this.setState({\n            id: 'redBackground',\n            hover: true\n        })\n    }\n\n    onMouseLeaveSquare() {\n        this.setState({\n            id: 'blueBackground',\n            hover: false\n        })\n    }\n    onClick() {\n        this.props.onClick()\n    }\n    shouldComponentUpdate(nextProps, nextState, nextContext)\n    {\n        if(nextState.id !== this.state.id || this.props.weight !== nextProps.weight || this.props.id !== nextProps.id)\n            return true\n        return false;\n    }\n    render() {\n        let stateId\n        if(!this.state.hover)\n            stateId = this.props.id\n        else\n            stateId = this.state.id\n        return (\n            <Button\n                variant=\"secondary\"\n               className=\"square\"\n                id={stateId}\n                onMouseEnter={this.onMouseEnterSquare.bind()}\n                onMouseLeave={this.onMouseLeaveSquare.bind()}\n                onClick={this.onClick.bind()}>\n                {this.props.weight}\n            </Button>\n        )\n    }\n}\n\nexport default Square\n\n","import React, {useState} from \"react\";\nimport MyCard from \"./CustomCard\"\nimport {useToasts} from \"react-toast-notifications\";\nimport Button from \"react-bootstrap/Button\";\nimport Square from \"./Square\"\nimport axios from \"axios\"\n\n\nconst Board = (props) => {\n    const testingUrl = \"https://visualizerbackend.herokuapp.com/\"\n    //const testingUrl = \"http://localhost:9000/\"\n    //can likely optimize blockedNodes\n    let [cardMessages, setCardMessages] = useState([\"Note: If the server has been idle, the initial query may take up to 10 seconds to complete.\",\n                                                            \"Backend is hosted at: https://visualizerbackend.herokuapp.com/\",\n                                                            \"To use:  Click a square to set a start location\",\n                                                                \"Then click another square to select a destination\",\n                                                                    \"You may also set barriers to change the available paths\",\n                                                                        \"For Dijkstra's SPF you can set the weight of each square \" +\n                                                                        \"changing the algorithm's chosen path\",\n                                                                        \"As a note: The path found may not be the 'straightest' path as diagonal moves are valid,\" +\n                                                                        \"but if you count the squares it will be equal to a more intuitive path\"])\n    const HEIGHT = props.heightAndWidth\n    const WIDTH = props.heightAndWidth\n    const SIZE = props.heightAndWidth * props.heightAndWidth\n    const [loading, setLoading] = useState(false)\n    let [backendOrFrontEnd, setBackEndOrFrontEnd] = useState([])\n    const [blockedNodes, setBlockedNodes] = useState(Array(SIZE).fill(false))\n    let [squares, setSquares] = useState(Array(SIZE).fill('grey'))\n    let [weights, setWeights] = useState(Array(SIZE).fill(1))\n    const [startMarkerIndex, setStartMarkerIndex] = useState(-1)\n    const [dropDownMenu, setDropDownMenu] = useState(Array(2).fill(false))\n    const [endMarkerIndex, setEndMarkerIndex] = useState(-1)\n    const [barrier, setBarrier] = useState(false)\n    const {addToast} = useToasts()\n    const [weightButton, setWeightButton] = useState(false)\n\n    const updateMessages = (data, sender) =>\n    {\n        cardMessages.unshift(data)\n        backendOrFrontEnd.unshift(sender)\n        setCardMessages(cardMessages.slice())\n        setBackEndOrFrontEnd(backendOrFrontEnd.slice())\n\n    }\n    const dialogToOutput = (date1, data) =>\n    {\n        setLoading(false)\n        const date2 = new Date()\n        const time = Math.abs(date2-date1)\n        updateMessages(data, 'Backend'  )\n        updateMessages('Query round trip time: ' +  time + \" milliseconds\", 'Frontend')\n    }\n    let backendDijkstra = async () =>\n    {\n        const date1 = new Date()\n        const valid = checkForValidMarkers()\n        if(valid !== null)\n        {\n            return valid\n        }\n        setLoading(true)\n        messageSeparator()\n        updateMessages('Sending data for Dijkstra', 'Frontend')\n        await axios.post(testingUrl + 'dijkstra', {startMarkerIndex, endMarkerIndex, SIZE, WIDTH, blockedNodes, weights })\n            .then(res=>{\n                dialogToOutput(date1, res.data[0])\n                if(!res.data[1] === false) {\n                    animateWithReturnPath(res.data[1])\n                }\n                else\n                    return (\n                        addToast(\"Path does not exist\", {\n                            appearance: 'warning',\n                            autoDismiss: true,\n                        }))\n            })\n            .catch(err => {console.error(err)})\n    }\n    const backendDepthFirstSearch = async () =>\n    {\n        const date1 = new Date()\n        const valid =checkForValidMarkers()\n        if(valid!== null) {\n            return valid\n        }\n        setLoading(true)\n        messageSeparator()\n        updateMessages('Sending data for DFS', 'Frontend')\n        await axios.post(testingUrl + 'depthFirstSearch', {startMarkerIndex, endMarkerIndex, SIZE, WIDTH, blockedNodes})\n            .then(res=>{\n                dialogToOutput(date1, res.data[0])\n                animateWithoutReturnPath(res.data[1])\n            })\n            .catch(err => {console.error(err)})\n    }\n    const messageSeparator = () =>\n    {\n        updateMessages(\" \", \" *************************  \")\n    }\n    let backendBreathFirstSearch = async () => {\n        let date1 = new Date()\n        const valid =checkForValidMarkers()\n        if(valid!== null)\n        {\n            return valid\n        }\n        setLoading(true)\n        messageSeparator()\n        updateMessages('Sending data for BFS', 'Frontend')\n        await axios.post(testingUrl + 'breathFirstSearch', {startMarkerIndex, endMarkerIndex, SIZE, WIDTH, HEIGHT, squares, blockedNodes, weights })\n            .then(res=>{\n                dialogToOutput(date1, res.data[0])\n                if(!res.data[1] === false) {\n                    animateWithReturnPath(res.data[1])\n                }\n                else\n                    return (\n                        addToast(\"Path does not exist\", {\n                            appearance: 'warning',\n                            autoDismiss: true,\n                        }))\n            })\n            .catch(err => {console.error(err)})\n    }\n\n    let animateWithoutReturnPath = (arr) => {\n\n        let tickIndex = 1\n        let timerID2\n        resetRun()\n        //reDrawBarrier()\n        const clearTickInterval = () => {\n            clearInterval(timerID2)\n        }\n\n        const tick2 = (tickArr) => {\n            if (tickIndex < tickArr.length - 1) {\n                //mutating the array directly :/\n                squares[tickArr[tickIndex]] = 'green'\n                tickIndex++\n                setSquares(squares.slice())\n            } else {\n                clearTickInterval(timerID2)\n                if(tickArr[tickArr.length - 1] === false) {\n                    setSquares(squares.slice())\n                    return (\n                        addToast(\"Path does not exist\", {\n                            appearance: 'warning',\n                            autoDismiss: true,\n                        }))\n                }\n                squares[tickArr[tickArr.length - 1]] = 'gold'\n                setSquares(squares.slice())\n                return (\n                    addToast(\"Path does exist\", {\n                        appearance: 'success',\n                        autoDismiss: true,\n                    }))\n            }\n        }\n        timerID2 = setInterval(\n            () => tick2(arr),\n            10\n        )\n    }\n    let animateWithReturnPath = (arr) => {\n        const findPathArr = arr[0]\n        const shortestPathArr = arr[1]\n        let tickIndex = 0\n        let timerID2\n        resetRun()\n        const clearTickInterval = () => {\n            clearInterval(timerID2)\n        }\n        let finishedAnimatingFindPath = false\n        const tick2 = (findPathArr, shortestPathArr) =>\n        {\n            if(!finishedAnimatingFindPath)\n            {\n                if (tickIndex <= findPathArr.length) {\n                    for(let i = 0; i < 4; i++)\n                    {\n                        //mutating the array directly -- doesn't seem to update promptly otherwise\n                        if (tickIndex <= findPathArr.length && findPathArr[tickIndex] !== endMarkerIndex && findPathArr[tickIndex] !== startMarkerIndex)\n                        {\n                            squares[findPathArr[tickIndex]] = 'green'\n                        }\n                        tickIndex++\n                    }\n                }\n                else\n                {\n                    finishedAnimatingFindPath = true\n                    squares[endMarkerIndex] = 'gold'\n                    tickIndex = 0\n                }\n                setSquares(squares.slice())\n            }\n            else\n            {\n                if(tickIndex < shortestPathArr.length - 1)\n                {\n                    squares[shortestPathArr[tickIndex]] = 'gold'\n                    setSquares(squares.slice())\n                    tickIndex++\n                }\n                else{\n                    squares[shortestPathArr[shortestPathArr.length - 1]] = 'gold'\n                    setSquares(squares.slice())\n                    clearTickInterval(timerID2)\n                }\n            }\n        }\n        timerID2 = setInterval(\n            () => tick2(findPathArr, shortestPathArr),\n            0\n        )\n    }\n\n    const setWeight = (count) => {\n        weights[count] = weights[count]+1\n        setWeights(weights.slice())\n    }\n\n    const checkForValidMarkers = () => {\n        if (startMarkerIndex < 0 || endMarkerIndex < 0) {\n            return (\n                addToast(\"Please select a starting and ending location first\", {\n                    appearance: 'warning',\n                    autoDismiss: true,\n                }))\n        } else return null\n    }\n\n    let renderSquare = (count) => {\n        return (<Square id={squares[count]} index={count} weight = {weights[count]} onClick={fork.bind(this, count)} key={count}/>)\n    }\n    let fork = (i) => {\n        if(weightButton)\n            setWeight(i)\n        else\n            SetMarker(i)\n    }\n    let SetMarker = (i) => {\n        let toastMessage = \"\"\n        let startStateMarker = startMarkerIndex;\n        let endStateMarker = endMarkerIndex;\n        if(blockedNodes[i]) //is already a blocked node.  Nothing to do with those\n        {\n            return\n        }\n        if (barrier) { //manually setting barrier\n            blockedNodes[i] = true\n            setBlockedNodes(blockedNodes.slice())\n            squares[i] = 'black'\n            setSquares(squares.slice())\n            return\n        } else if (startStateMarker === i) {\n            squares[i] = 'grey'\n            startStateMarker = -1\n            //arr[i] = undefined\n            toastMessage = \"Deselected Start Location\"\n            resetRun()\n           // clearAlgorithm()\n           // resetRun()\n        } else if (startStateMarker < 0 && endStateMarker === i) {\n            endStateMarker = -1\n            squares[i] = 'grey'\n            resetRun()\n            toastMessage = \"Deselected End Location\"\n        } else if (startStateMarker < 0) {\n            startStateMarker = i\n            squares[i] = 'startMarker'\n            toastMessage = \"Start Location Selected\"\n        } else if (endStateMarker === i) {\n            squares[i] = 'grey'\n            endStateMarker = -1\n            resetRun()\n            toastMessage = \"Deselected End Location\"\n        } else if (endStateMarker < 0) {\n            endStateMarker = i\n            squares[i] = 'endMarker'\n            toastMessage = \"Selected End Location\"\n        } else {\n            return\n        }\n        setStartMarkerIndex(startStateMarker)\n        setEndMarkerIndex(endStateMarker)\n        squares[startStateMarker] = 'startMarker'\n        squares[endStateMarker] = 'endMarker'\n        setSquares(squares.slice())\n        return (\n            addToast(toastMessage, {\n                appearance: 'info',\n                autoDismiss: true,\n            }))\n    }\n\n    const clearSquares = () => {\n        //squares not changing without setting squares explicitly\n        for(let i = 0; i < squares.length; i++) {\n            squares = Array(SIZE).fill(null)\n            setSquares(Array(SIZE).fill(null))\n        }\n    }\n    const resetRun = () =>{\n        for(let i = 0; i < squares.length; i++) {\n            if (squares[i] === 'green' || squares[i] === 'gold') {\n                squares[i] = 'grey'\n            }\n        }\n        setSquares(squares.slice())\n    }\n    const clearBarrier = () => {\n        setBlockedNodes(Array(SIZE).fill(false))\n    }\n    const clearMarkers = () => {\n        setStartMarkerIndex(-1)\n        setEndMarkerIndex(-1)\n    }\n    const clearWeights = () => {\n        setWeights(Array(SIZE).fill(1))\n    }\n    const clearGraph = () => {\n        clearSquares()\n        clearBarrier()\n        clearMarkers()\n        clearWeights()\n    }\n    const createBarrier = () => {\n        setBarrier(!barrier)\n        if(weightButton)\n        {\n            setWeightButtonFunction()\n        }\n        if (barrier)\n            document.getElementById(\"barrier\").innerText = \"Draw Barrier\"\n        else\n            document.getElementById(\"barrier\").innerText = \"Disable Barrier\"\n    }\n\n    const setWeightButtonFunction = () =>\n    {\n        setWeightButton(!weightButton)\n        if(barrier)\n        {\n            createBarrier()\n        }\n        if(weightButton)\n            document.getElementById(\"addWeights\").innerText = \"Set Weights\"\n        else\n            document.getElementById(\"addWeights\").innerText = \"Toggle Weights Off\"\n\n    }\n    const randomizeWeights = async () =>\n    {\n        let date1 = new Date()\n        setLoading(true)\n        messageSeparator()\n        updateMessages('Sending data for random weight generation', 'Frontend')\n        await axios.post(testingUrl + 'weightGeneration', {SIZE})\n            .then(res => {\n                setLoading(false)\n                dialogToOutput(date1, res.data[0])\n                setWeights(res.data[1])\n            })\n    }\n    const generateBacktrack = async () =>\n    {\n        let date1 = new Date()\n        setLoading(true)\n        messageSeparator()\n        updateMessages('Sending data for maze generation', 'Frontend')\n        await axios.post(testingUrl + 'generateBacktracking', {startMarkerIndex, endMarkerIndex, SIZE, WIDTH, HEIGHT, squares, blockedNodes, weights })\n            .then(res=>{\n                setLoading(false)\n                dialogToOutput(date1, res.data[0])\n                let arr = res.data[1]\n                let tempBlockedNodes = Array(SIZE).fill(false)\n                for(let i = 0; i < arr.length; i++)\n                {\n                    if(arr[i] === 'black')\n                        tempBlockedNodes[i] = true\n                }\n                setBlockedNodes(tempBlockedNodes)\n                setSquares(res.data[1])\n            })\n            .catch(err => {console.error(err)})\n    }\n    const generatePrimsTree = async () =>\n    {\n        let date1 = new Date()\n        setLoading(true)\n        messageSeparator()\n        updateMessages('Sending data for maze generation', 'Frontend')\n        await axios.post(testingUrl + 'primsTree', {startMarkerIndex, SIZE, WIDTH, blockedNodes, weights })\n            .then(res=>{\n                /*setLoading(false)\n                dialogToOutput(date1, res.data[0])\n                let arr = res.data[1]\n                let tempBlockedNodes = Array(SIZE).fill(false)\n                for(let i = 0; i < arr.length; i++)\n                {\n                    if(arr[i] === 'black')\n                        tempBlockedNodes[i] = true\n                }\n                setBlockedNodes(tempBlockedNodes)\n                setSquares(res.data[1])*/\n            })\n            .catch(err => {console.error(err)})\n    }\n    const generatePrimsMaze = async () =>\n    {\n        let date1 = new Date()\n        setLoading(true)\n        messageSeparator()\n        updateMessages('Sending data for maze generation', 'Frontend')\n        await axios.post(testingUrl + 'generatePrimsMaze', {startMarkerIndex, endMarkerIndex, SIZE, WIDTH, HEIGHT, squares, blockedNodes, weights })\n            .then(res=>{\n                setLoading(false)\n                dialogToOutput(date1, res.data[0])\n                let arr = res.data[1]\n                let tempBlockedNodes = Array(SIZE).fill(false)\n                for(let i = 0; i < arr.length; i++)\n                {\n                    if(arr[i] === 'black')\n                        tempBlockedNodes[i] = true\n                }\n                setBlockedNodes(tempBlockedNodes)\n                setSquares(res.data[1])\n            })\n            .catch(err => {console.error(err)})\n    }\n    const clearCardMessages = () =>\n    {\n        setCardMessages([])\n        setBackEndOrFrontEnd([])\n    }\n\n    let parent = []\n    let count = 0\n    for (let i = 0; i < WIDTH; i++) {\n        let children = []\n        for (let j = 0; j < HEIGHT; j++) {\n            children.push(renderSquare(count))\n            count++\n        }\n        parent.push(<div key={i} className={\"board-row\"}>{children}</div>)\n    }\n    const toggleOpen = (i) =>\n    {\n        const temp = [false, false]\n        temp[i] = !dropDownMenu[i]\n\n        setDropDownMenu(temp)\n    }\n    const menuClass1 = `dropdown-menu ${ dropDownMenu[0]? \" show\": \"\"}`\n    const menuClass2 = `dropdown-menu ${ dropDownMenu[1]? \" show\": \"\"}`\n    return (\n        <div id={\"box\"}>\n            <div id={\"leftBox\"}>\n                    <div id = \"buttons1\" className = \"btn-group-vertical\" role={\"group\"}>\n                        <div className=\"btn-group\" role=\"group\">\n                            <button id=\"btnGroupDrop\" type=\"button\"  onClick = {toggleOpen.bind(this, 0)} className=\"btn btn-primary dropdown-toggle\"\n                                data-toggle=\"dropdown-menu\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                                Shortest Path Algorithms\n                            </button>\n                            <div className={menuClass1} aria-labelledby=\"btnGroupDrop1\">\n                                <a id={\"menuButton\"} className = \"btn btn-primary-controlButton\" onClick = { backendDepthFirstSearch.bind(this) }>\n                                    Depth First Search\n                                    <p> (Does path Exist)</p>\n                                </a>\n                                <a id={\"menuButton\"} className = \"btn btn-primary-controlButton\" onClick = { backendBreathFirstSearch.bind(this) }>\n                                    Breath-First Search\n                                    <p>(Shortest Path)</p>\n                                </a>\n                                <a id={\"menuButton\"} className = \"btn btn-primary-controlButton\" onClick = { backendDijkstra.bind(this) }>\n                                    Dijkstra's SPF\n                                </a>\n                                <a id={\"menuButton\"} className = \"btn btn-primary-controlButton1\" onClick = { generatePrimsTree.bind(this) }>\n                                    Prim's Minimum Spanning Tree\n                                </a>\n                            </div>\n                        </div>\n                        <div className=\"btn-group\" role=\"group\">\n                            <button id=\"btnGroupDrop\" type=\"button\"  onClick = {toggleOpen.bind(this, 1)} className=\"btn btn-primary dropdown-toggle\"\n                                    data-toggle=\"dropdown-menu\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                                Maze Generation Algorithms\n                            </button>\n                            <div className={menuClass2} aria-labelledby=\"btnGroupDrop11\">\n                                <a id={\"menuButton\"} className = \"btn btn-primary-controlButton1\" onClick = { generatePrimsMaze.bind(this) }>\n                                    Prim's Maze\n                                </a>\n                                <a id={\"menuButton\"} className = \"btn btn-primary-controlButton1\" onClick = { generateBacktrack.bind(this) }>\n                                    Recursive Backtracking\n                                </a>\n\n                            </div>\n                        </div>\n                    <Button className = \"btn btn-lg btn-primary-controlButton\" onClick = {clearGraph.bind(this)}>Clear Graph</Button>\n                    <Button className = \"btn btn-lg btn-primary-controlButton\"  id = \"barrier\" onClick = { createBarrier.bind(this)}>Draw Barrier</Button>\n                    <Button className = \"btn btn-lg btn-primary-controlButton\" id =\"addWeights\" onClick = { setWeightButtonFunction.bind(this) }>Set Weights</Button>\n                        <Button className = \"btn btn-lg btn-primary-controlButton\" id =\"randomizeWeights\" onClick = { randomizeWeights.bind(this)}>Randomize Weights</Button>\n                    <Button className = \"btn btn-lg btn-primary-controlButton\" id = \"randomizeWeights\" onClick = { clearWeights.bind(this)}>Remove Weights</Button>\n                    </div>\n            </div>\n            <div id={\"centerBox\"}>\n                {parent}\n                <div id={\"rightBox\"}>\n                    <MyCard loading = {loading} clearMessages = {clearCardMessages.bind(this)} messages = {cardMessages} header = {backendOrFrontEnd} />\n\n                </div>\n            </div>\n\n\n        </div>\n    );\n}\n\nexport default Board\n\n\n/*\n\n */","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport 'bootstrap/dist/css/bootstrap.css'\nimport Board from './Board.js'\nimport {ToastProvider} from \"react-toast-notifications\";\n\nclass Game extends React.Component {\n    constructor(props)\n    {\n        super(props)\n        this.state =({\n            //must be square\n            heightAndWidth : 40,\n        })\n    }\n    render() {\n        return (\n\n            <div id =\"body\" className=\"game\">\n\n                <div className=\"game-board\">\n                    <ToastProvider id = {\"toasty\"} autoDismissTimeout={2000} placement=\"bottom-center\">\n                        <Board id={\"board\"} heightAndWidth = {this.state.heightAndWidth}/>\n                    </ToastProvider>\n                </div>\n            </div>\n\n        );\n    }\n}\n\nReactDOM.render(\n    <Game />,\n\n\n    document.getElementById('root')\n);\n\n\n"],"sourceRoot":""}