{"version":3,"sources":["CustomCard.js","Square.js","Board.js","index.js"],"names":["MyCard","props","holder","i","messages","length","push","Card","Title","key","header","Text","className","Header","Button","id","onClick","clearMessages","bind","Body","Square","state","hover","weight","onMouseEnterSquare","onMouseLeaveSquare","this","setState","nextProps","nextState","nextContext","stateId","variant","onMouseEnter","onMouseLeave","React","Component","Board","useState","cardMessages","setCardMessages","backendOrFrontEnd","setBackEndOrFrontEnd","Array","height","width","fill","blockedNodes","setBlockedNodes","squares","setSquares","weights","setWeights","startMarkerIndex","setStartMarkerIndex","dropDownMenu","setDropDownMenu","endMarkerIndex","setEndMarkerIndex","clicked","setClicked","barrier","setBarrier","addToast","useToasts","weightButton","setWeightButton","updateMessages","data","sender","unshift","dialogToOutput","date1","date2","Date","time","Math","abs","backendDijkstra","a","valid","checkForValidMarkers","messageSeparator","axios","post","SIZE","WIDTH","then","res","animateWithReturnPath","catch","err","console","error","backendDepthFirstSearch","animateWithoutReturnPath","backendBreathFirstSearch","HEIGHT","arr","clearSquares","reDrawBarrier","timerID2","tickIndex","tick2","tickArr","clearInterval","appearance","autoDismiss","slice","placement","setInterval","findPathArr","shortestPathArr","finishedAnimatingFindPath","renderSquare","count","index","fork","setWeight","SetMarker","toastMessage","startStateMarker","endStateMarker","undefined","createBarrier","setWeightButtonFunction","document","getElementById","innerText","parent","children","j","menuClass","role","type","data-toggle","aria-haspopup","aria-expanded","aria-labelledby","Game","autoDismissTimeout","ReactDOM","render"],"mappings":"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","file":"static/js/main.136d4afb.chunk.js","sourcesContent":["import Card from \"react-bootstrap/Card\";\nimport Button from \"react-bootstrap/Button\";\nimport React from \"react\";\n\nconst MyCard = (props) =>\n{\n    const holder = [];\n    for(let i = 0; i < props.messages.length; i++)\n    {//values will not be sorted or changed in any way such that using the index for the key should be fine\n        holder.push( <Card.Title key = {\"Title\" + i} >{props.header[i]}</Card.Title>)\n        holder.push(  <Card.Text key = {\"Message\" + i}>{props.messages[i]}</Card.Text>)\n    }\n    return (\n    <Card className=\"text-center\">\n        <Card.Header>\n            <Button id={\"headerButton\"} onClick = {props.clearMessages.bind(this)}>Clear Messages</Button>\n            Messages Sent and Received\n        </Card.Header>\n        <Card.Body>\n            {holder}\n        </Card.Body>\n    </Card>)\n}\nexport default MyCard","import React from \"react\";\nimport Button from \"react-bootstrap/Button\";\nclass Square extends React.Component {\n    constructor(props) {\n        super(props)\n        this.state = {\n            hover: false,\n            id: '',\n            weight: 0\n        }\n        this.onMouseEnterSquare = this.onMouseEnterSquare.bind(this)\n        this.onMouseLeaveSquare = this.onMouseLeaveSquare.bind(this)\n        this.onClick = this.onClick.bind(this)\n    }\n\n    onMouseEnterSquare() {\n        this.setState({\n            id: 'redBackground',\n            hover: true\n        })\n    }\n\n    onMouseLeaveSquare() {\n        this.setState({\n            id: 'blueBackground',\n            hover: false\n        })\n    }\n    onClick() {\n        this.props.onClick()\n        //this.setWeight()\n\n    }\n    shouldComponentUpdate(nextProps, nextState, nextContext)\n    {\n        if(nextState.id !== this.state.id || this.props.weight !== nextProps.weight || this.props.id !== nextProps.id)\n            return true\n        return false;\n    }\n    render() {\n        let stateId\n        if(!this.state.hover)\n            stateId = this.props.id\n        else\n            stateId = this.state.id\n        return (\n            <Button\n                variant=\"secondary\"\n                className=\"square\"\n                id={stateId}\n                onMouseEnter={this.onMouseEnterSquare.bind()}\n                onMouseLeave={this.onMouseLeaveSquare.bind()}\n                onClick={this.onClick.bind()}>\n                {this.props.weight}\n            </Button>\n        )\n    }\n}\n\nexport default Square\n\n","import React, {useState} from \"react\";\nimport MyCard from \"./CustomCard\"\nimport {useToasts} from \"react-toast-notifications\";\nimport Button from \"react-bootstrap/Button\";\nimport Square from \"./Square\"\nimport axios from \"axios\"\n\n\nconst Board = (props) => {\n    //can likely optimize blockedNodes\n    let [cardMessages, setCardMessages] = useState([\"Note: If the server has been idle, the initial query may take several seconds to complete.\",\n                                                            \"Backend is hosted at: https://visualizerbackend.herokuapp.com/\",\n                                                            \"To use:  Click a square to set a start location\",\n                                                                \"Then click another square to select a destination\",\n                                                                    \"You may also set barriers to change the available paths\",\n                                                                        \"Additionally, for Dijkstra's SPF you can set the weight of each square \" +\n                                                                        \"changing the algorithm's chosen path\"])\n    let [backendOrFrontEnd, setBackEndOrFrontEnd] = useState([])\n    const [blockedNodes, setBlockedNodes] = useState(Array(props.height * props.width).fill(false))\n    let [squares, setSquares] = useState(Array(props.height * props.width).fill(false))\n    let [weights, setWeights] = useState(Array(props.height * props.width).fill(1))\n    const [startMarkerIndex, setStartMarkerIndex] = useState(-1)\n    const [dropDownMenu, setDropDownMenu] = useState(false)\n    const [endMarkerIndex, setEndMarkerIndex] = useState(-1)\n    const [clicked, setClicked] = useState(false)\n    const [barrier, setBarrier] = useState(false)\n    const {addToast} = useToasts()\n    const [weightButton, setWeightButton] = useState(false)\n\n    const updateMessages = (data, sender) =>\n    {\n        cardMessages.unshift(data)\n        backendOrFrontEnd.unshift(sender)\n        setCardMessages(cardMessages)\n        setBackEndOrFrontEnd(backendOrFrontEnd)\n    }\n    const dialogToOutput = (date1, data) =>\n    {\n        const date2 = new Date()\n        const time = Math.abs(date2-date1)/1000\n        updateMessages(data, 'Backend'  )\n        updateMessages('Query round trip time: ' +  time + \" seconds\", 'Frontend')\n    }\n    let backendDijkstra = async () =>\n    {\n        const date1 = new Date()\n        const valid = checkForValidMarkers()\n        if(valid !== null)\n        {\n            return valid\n        }\n        setClicked(true)\n        messageSeparator()\n        updateMessages('Sending data for Dijkstra', 'Frontend')\n        await axios.post('https://visualizerbackend.herokuapp.com/dijkstra', {startMarkerIndex, endMarkerIndex, SIZE, WIDTH, blockedNodes, weights })\n            .then(res=>{\n                dialogToOutput(date1, res.data[0])\n                animateWithReturnPath(res.data[1])\n            })\n            .catch(err => {console.error(err)})\n        //let dict = createContainer(SIZE, WIDTH, blockedNodes)\n        //const k = new Dijkstra(weights, dict, startMarkerIndex, endMarkerIndex, SIZE)\n        //let shortestPath = k.dijkstra()\n        //animateWithReturnPath(shortestPath)\n    }\n    const backendDepthFirstSearch = async () =>\n    {\n        const date1 = new Date()\n        const valid =checkForValidMarkers()\n        if(valid!== null) {\n            return valid\n        }\n        setClicked(true)\n        messageSeparator()\n        updateMessages('Sending data for DFS', 'Frontend')\n        await axios.post('https://visualizerbackend.herokuapp.com/depthFirstSearch', {startMarkerIndex, endMarkerIndex, SIZE, WIDTH, blockedNodes})\n            .then(res=>{\n                dialogToOutput(date1, res.data[0])\n                animateWithoutReturnPath(res.data[1])\n            })\n            .catch(err => {console.error(err)})\n    }\n    const messageSeparator = () =>\n    {\n        updateMessages(\" \", \" *************************  \")\n    }\n    let backendBreathFirstSearch = async () => {\n        let date1 = new Date()\n        const valid =checkForValidMarkers()\n        if(valid!== null)\n        {\n            return valid\n        }\n        setClicked(true)\n        messageSeparator()\n        updateMessages('Sending data for BFS', 'Frontend')\n        await axios.post('https://visualizerbackend.herokuapp.com/breathFirstSearch', {startMarkerIndex, endMarkerIndex, SIZE, WIDTH, HEIGHT, squares, blockedNodes, weights })\n            .then(res=>{\n                dialogToOutput(date1, res.data[0])\n                animateWithReturnPath(res.data[1])\n            })\n            .catch(err => {console.error(err)})\n    }\n\n    let animateWithoutReturnPath = (arr) => {\n        clearSquares()\n        reDrawBarrier()\n        let tickIndex = 1\n        let timerID2\n        if (clicked === true)\n            return\n\n        const clearTickInterval = () => {\n            clearInterval(timerID2)\n        }\n        const tick2 = (tickArr) => {\n            if (tickIndex < tickArr.length - 1) {\n                //mutating the array directly :/\n                squares[tickArr[tickIndex]] = 'green'\n                tickIndex++\n                setSquares(squares.slice())\n            } else {\n                clearTickInterval(timerID2)\n                setClicked(false)\n                if(tickArr[tickArr.length - 1] === false) {\n                    return (\n                        addToast(\"Path does not exist\", {\n                            appearance: 'warning',\n                            autoDismiss: true,\n                        }))\n                }\n                squares[tickArr[tickArr.length - 1]] = 'gold'\n                setSquares(squares.slice())\n                return (\n                    addToast(\"Path does exist\", {\n                        placement: 'top-middle',\n                        appearance: 'success',\n                        autoDismiss: true,\n                    }))\n            }\n        }\n        timerID2 = setInterval(\n            () => tick2(arr),\n            10\n        )\n    }\n\n    let animateWithReturnPath = (arr) => {\n        const findPathArr = arr[0]\n        const shortestPathArr = arr[1]\n        clearSquares()\n        reDrawBarrier()\n        let tickIndex = 0\n        let timerID2\n        if (clicked === true) {\n            return\n        }\n        const clearTickInterval = () => {\n            clearInterval(timerID2)\n        }\n        let finishedAnimatingFindPath = false\n        const tick2 = (findPathArr, shortestPathArr) => {\n            if(!finishedAnimatingFindPath) {\n                if (tickIndex < findPathArr.length) {\n                    //mutating the array directly -- doesn't seem to update promptly otherwise\n                    //console.log(\"this is tickIndex: \" + tickIndex)\n                    //console.log(\"this is findPathArr[tickIndex]: \" + findPathArr[tickIndex])\n                    if(!(findPathArr[tickIndex] === endMarkerIndex) && !(findPathArr[tickIndex] === startMarkerIndex))\n                        squares[findPathArr[tickIndex]] = 'green'\n                    tickIndex++\n                    setSquares(squares.slice())\n                } else {\n                    finishedAnimatingFindPath = true\n                    squares[endMarkerIndex] = 'gold'\n                    setSquares(squares.slice())\n                    tickIndex = 0\n                }\n            }\n            else\n            {\n                if(tickIndex < shortestPathArr.length - 1)\n                {\n                    squares[shortestPathArr[tickIndex]] = 'gold'\n                    setSquares(squares.slice())\n                    tickIndex++\n                }\n                else{\n                    squares[shortestPathArr[shortestPathArr.length - 1]] = 'gold'\n                    setSquares(squares.slice())\n                    clearTickInterval(timerID2)\n                    setClicked(false)\n                }\n            }\n        }\n        timerID2 = setInterval(\n            () => tick2(findPathArr, shortestPathArr),\n            10\n        )\n    }\n\n    const setWeight = (count) => {\n        weights[count] = weights[count]+1\n        setWeights(weights.slice())\n    }\n\n    const checkForValidMarkers = () => {\n        if (startMarkerIndex < 0 && endMarkerIndex < 0) {\n            return (\n                addToast(\"Please select a starting and ending location first\", {\n                    appearance: 'warning',\n                    autoDismiss: true,\n                }))\n        } else return null\n    }\n\n    let renderSquare = (count) => {\n        let state = 'slateGrey'\n        if (squares[count] === 'gold' || squares[count] === 'green' || squares[count] === 'black')\n            state = squares[count]\n        else if (count === startMarkerIndex)\n            state = 'startMarker'\n        else if (count === endMarkerIndex)\n            state = 'endMarker'\n        return (<Square id={state} index={count} weight = {weights[count]} onClick={fork.bind(this, count)} key={count}/>)\n    }\n    let fork = (i) => {\n        if(weightButton)\n            setWeight(i)\n        else\n            SetMarker(i)\n    }\n    let SetMarker = (i) => {\n        let toastMessage = \"\"\n        let arr = squares.slice()\n        let startStateMarker = startMarkerIndex;\n        let endStateMarker = endMarkerIndex;\n        if (barrier) {\n            blockedNodes[i] = true\n            setBlockedNodes(blockedNodes.slice())\n            squares[i] = 'black'\n            setSquares(squares.slice())\n            return\n        } else if (startStateMarker === i) {\n            startStateMarker = -1\n            arr[i] = undefined\n            toastMessage = \"Deselected Start Location\"\n        } else if (startStateMarker < 0 && endStateMarker === i) {\n            endStateMarker = -1\n            //arr[i] = undefined\n            toastMessage = \"Deselected End Location\"\n        } else if (startStateMarker < 0) {\n            startStateMarker = i\n            //arr[i] = 'O'\n            toastMessage = \"Start Location Selected\"\n        } else if (endStateMarker === i) {\n            endStateMarker = -1\n            //arr[i] = undefined\n            toastMessage = \"Deselected End Location\"\n        } else if (endStateMarker < 0) {\n            endStateMarker = i\n            //arr[i] = 'X'\n            toastMessage = \"Selected End Location\"\n        } else {\n            return\n        }\n        setStartMarkerIndex(startStateMarker)\n        setEndMarkerIndex(endStateMarker)\n        setSquares(squares)\n        return (\n            addToast(toastMessage, {\n                appearance: 'info',\n                autoDismiss: true,\n            }))\n    }\n\n    const clearSquares = () => {\n        //squares not changing without setting squares explicitly\n        squares = Array(props.height * props.width).fill(null)\n        setSquares(Array(props.height * props.width).fill(null))\n\n    }\n    const reDrawBarrier = () =>{\n        for(let i = 0; i < squares.length; i++)\n        {\n            if(blockedNodes[i] === true)\n            {\n                squares[i] = 'black'\n            }\n        }\n        setSquares(Array(squares.slice()))\n    }\n    const clearBarrier = () => {\n        setBlockedNodes(Array(props.height * props.width).fill(false))\n    }\n    const clearMarkers = () => {\n        setStartMarkerIndex(-1)\n        setEndMarkerIndex(-1)\n    }\n    const clearWeights = () => {\n        setWeights(Array(props.height * props.width).fill(1))\n    }\n    const clearGraph = () => {\n        clearSquares()\n        clearBarrier()\n        clearMarkers()\n        clearWeights()\n    }\n    const createBarrier = () => {\n        setBarrier(!barrier)\n        if(weightButton)\n        {\n            setWeightButtonFunction()\n        }\n        if (barrier)\n            document.getElementById(\"barrier\").innerText = \"Draw Barrier\"\n        else\n            document.getElementById(\"barrier\").innerText = \"Disable Barrier\"\n    }\n\n    const setWeightButtonFunction = () =>\n    {\n        setWeightButton(!weightButton)\n        if(barrier)\n        {\n            createBarrier()\n        }\n        if(weightButton)\n            document.getElementById(\"addWeights\").innerText = \"Set Weights\"\n        else\n            document.getElementById(\"addWeights\").innerText = \"Toggle Weights Off\"\n\n    }\n    const clearCardMessages = () =>\n    {\n        setCardMessages([])\n        setBackEndOrFrontEnd([])\n    }\n\n    let parent = []\n    let count = 0\n    const HEIGHT = props.height\n    const WIDTH = props.width\n    const SIZE = HEIGHT * WIDTH\n    for (let i = 0; i < HEIGHT; i++) {\n        let children = []\n        for (let j = 0; j < WIDTH; j++) {\n            children.push(renderSquare(count))\n            count++\n        }\n        parent.push(<div key={i} className={\"board-row\"}>{children}</div>)\n    }\n    const toggleOpen = () => setDropDownMenu(!dropDownMenu)\n    const menuClass = `dropdown-menu ${ dropDownMenu? \" show\": \"\"}`\n    return (\n        <div id={\"box\"}>\n            <div id={\"leftBox\"}>\n                    <div id = \"buttons1\" className = \"btn-group-vertical\" role={\"group\"}>\n                    <div className=\"btn-group\" role=\"group\">\n                        <button id=\"btnGroupDrop1\" type=\"button\"  onClick = {toggleOpen.bind(this)} className=\"btn btn-primary dropdown-toggle\"\n                                data-toggle=\"dropdown-menu\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                            Algorithms\n                        </button>\n                        <div className={menuClass} aria-labelledby=\"btnGroupDrop1\">\n                            <a id={\"menuButton\"} className = \"btn btn-primary-controlButton\" onClick = { backendDepthFirstSearch.bind(this) }>Backend DFS>\n                                Depth First Search\n                                <p> (Does path Exist)</p>\n                          </a>\n                            <a id={\"menuButton\"} className = \"btn btn-primary-controlButton\" onClick = { backendBreathFirstSearch.bind(this) }>\n                                Breath-First Search\n                                <p>(Shortest Path)</p>\n                            </a>\n                            <a id={\"menuButton\"} className = \"btn btn-primary-controlButton\" onClick = { backendDijkstra.bind(this) }>\n                                Dijkstra's SPF\n                            </a>\n                        </div>\n                    </div>\n                    <Button className = \"btn btn-primary-controlButton\" onClick = {clearGraph.bind(this)}>Clear Graph</Button>\n                    <Button className = \"btn btn-primary-controlButton\"  id = \"barrier\" onClick = { createBarrier.bind(this)}>Draw Barrier</Button>\n                    <Button className = \"btn btn-primary-controlButton\" id =\"addWeights\" onClick = { setWeightButtonFunction.bind(this) }>Set Weights</Button>\n                    </div>\n\n            </div>\n        <div id={\"centerBox\"}>\n         {parent}\n        </div>\n            <div id={\"rightBox\"}>\n                  <MyCard clearMessages = {clearCardMessages.bind(this)} messages = {cardMessages} header = {backendOrFrontEnd} />\n            </div>\n\n\n\n        </div>\n    );\n}\n\nexport default Board\n\n\n/*\n  <a id={\"menuButton\"} className = \"btn btn-primary-dropdown-item\" onClick = {depthFirstSearch.bind(this, SIZE, WIDTH, HEIGHT)} >\n                                Depth First Search\n                                <p> (Does path Exist)</p>\n                          </a>\n                            <a id={\"menuButton\"} className = \"btn btn-primary-dropdown-item\" onClick = {breathFirstSearch.bind(this, SIZE, WIDTH, HEIGHT)} >\n                                Breath-First Search\n                                <p>(Shortest Path)</p>\n                            </a>\n                            <a id={\"menuButton\"} className = \"btn btn-primary-dropdown-item\" onClick = {dijkstra.bind(this, SIZE, WIDTH, HEIGHT)} >\n                                Dijkstra's SPF\n                            </a>\n\n\n\n  <div id = \"buttons2\" className = \"btn-group-vertical\" role={\"group\"}>\n\n                         </div>\n\n\n                              <Button className = \"btn btn-primary-controlButton\" id =\"addWeights\" onClick = { backendDepthFirstSearch.bind(this) }>Backend DFS</Button>\n                <Button className = \"btn btn-primary-controlButton\" id =\"addWeights\" onClick = { backendBreathFirstSearch.bind(this) }>Backend BFS</Button>\n                <Button className = \"btn btn-primary-controlButton\" id =\"addWeights\" onClick = { backendDijkstra.bind(this) }>Backend Dijkstra</Button>\n\n */\n\n/*\n\n       let breathFirstSearch = () => {\n        const valid =checkForValidMarkers()\n        if(valid!== null)\n        {\n            return valid\n        }\n        setClicked(true)\n        const k = new BreathFirstSearch()\n        let dict = createContainer(SIZE, WIDTH, blockedNodes)\n        let shortestPath = k.BFS(startMarkerIndex, endMarkerIndex, dict, SIZE)\n        animateWithReturnPath(shortestPath)\n    }\n    let depthFirstSearch = (SIZE, HEIGHT, WIDTH) => {\n        const valid =checkForValidMarkers()\n        if(valid!== null) {\n            return valid\n        }\n        setClicked(true)\n        const k = new DepthFirstSearch()\n        let dict = createContainer(SIZE, WIDTH, blockedNodes)\n        let shortestPath = k.DFS(startMarkerIndex, endMarkerIndex, dict, SIZE)\n        animateWithoutReturnPath(shortestPath)\n    }\n     let dijkstra = () =>\n    {\n        const valid = checkForValidMarkers()\n        if(valid !== null)\n        {\n            return valid\n        }\n        setClicked(true)\n\n        let dict = createContainer(SIZE, WIDTH, blockedNodes)\n        const k = new Dijkstra(weights, dict, startMarkerIndex, endMarkerIndex, SIZE)\n        let shortestPath = k.dijkstra()\n        animateWithReturnPath(shortestPath)\n    }\n */","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport 'bootstrap/dist/css/bootstrap.css'\nimport Board from './Board.js'\nimport {ToastProvider} from \"react-toast-notifications\";\n\nclass Game extends React.Component {\n    constructor(props)\n    {\n        super(props)\n        this.state =({\n            height : 20,\n            width : 20,\n        })\n    }\n    render() {\n        return (\n\n            <div id =\"body\" className=\"game\">\n\n                <div className=\"game-board\">\n                    <ToastProvider autoDismissTimeout={2000} placement=\"bottom-center\">\n                        <Board height = {this.state.height} width = {this.state.width}/>\n                    </ToastProvider>\n                </div>\n\n                <div className=\"game-info\">\n                </div>\n            </div>\n\n        );\n    }\n}\n\nReactDOM.render(\n    <Game />,\n\n\n    document.getElementById('root')\n);\n\n\n"],"sourceRoot":""}