{"version":3,"sources":["DepthFirstSearch.js","Square.js","CreateContainer.js","BreathFirstSearch.js","Dijkstra.js","Board.js","index.js"],"names":["DepthFirstSearch","this","DFSUtil","bind","DFS","visited","start","end","dictionary","found","orderOfSearch","push","i","length","SIZE","Array","fill","Square","props","state","hover","id","weight","onMouseEnterSquare","onMouseLeaveSquare","onClick","setState","nextProps","nextState","nextContext","stateId","Button","variant","className","onMouseEnter","onMouseLeave","React","Component","createContainer","size","width","blockedNodes","dict","tempMap","Map","set","key","value","get","sort","j","splice","Set","BreathFirstSearch","shortestPathBack","BFS","BFSUtil","queue","node","shift","newNode","followPathBack","parent","Dijkstra","weights","searchingVisited","distances","Infinity","dijkstra","dijkstraUtil","computeShortestPath","index","console","log","minWeight","minWeightIndex","Object","keys","finalMinDistance","Number","MAX_VALUE","finalMinIndex","entries","slice","totalDistance","Board","useState","height","setBlockedNodes","squares","setSquares","setWeights","startMarkerIndex","setStartMarkerIndex","dropDownMenu","setDropDownMenu","endMarkerIndex","setEndMarkerIndex","clicked","setClicked","barrier","setBarrier","addToast","useToasts","weightButton","setWeightButton","animateWithoutReturnPath","arr","clearSquares","reDrawBarrier","timerID2","tickIndex","tick2","tickArr","clearInterval","appearance","autoDismiss","setInterval","animateWithReturnPath","findPathArr","shortestPathArr","finishedAnimatingFindPath","checkForValidMarkers","breathFirstSearch","valid","k","WIDTH","shortestPath","renderSquare","count","fork","setWeight","SetMarker","toastMessage","startStateMarker","endStateMarker","undefined","createBarrier","setWeightButtonFunction","document","getElementById","innerText","HEIGHT","children","menuClass","role","type","data-toggle","aria-haspopup","aria-expanded","aria-labelledby","Game","autoDismissTimeout","placement","ReactDOM","render"],"mappings":"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","file":"static/js/main.7113db73.chunk.js","sourcesContent":["export default class DepthFirstSearch\n{\n    constructor()\n    {\n        this.DFSUtil = this.DFSUtil.bind(this)\n        this.DFS = this.DFS.bind(this)\n    }\n    DFSUtil(visited, start, end, dictionary, found, orderOfSearch)\n    {\n        if(found[0] === true) return  //stop the search\n        if(start === end) //eureka!\n        {\n            found[0] = true\n            visited[start] = true\n            orderOfSearch.push(start)\n        }\n        visited[start] = true\n        orderOfSearch.push(start) //this is to track the order of visited nodes\n\n        for(let i = 0; i < dictionary[start][0].length; i++)\n        {\n            if(dictionary[i][0] !== -1 && visited[dictionary[start][0][i]] === false)\n            {\n                this.DFSUtil(visited, dictionary[start][0][i], end, dictionary, found, orderOfSearch)\n            }\n        }\n    }\n    DFS(start, end, dictionary, SIZE){\n        let visited = Array(SIZE).fill(false)\n        let orderOfSearch = []\n        let found = [false]\n        this.DFSUtil(visited, start, end, dictionary, found, orderOfSearch)\n        if(found[0] === false)\n        {\n            return [...orderOfSearch, false]\n        }\n        return orderOfSearch\n    }\n}\n\n\n\n\n\n\n","import React from \"react\";\nimport Button from \"react-bootstrap/Button\";\nclass Square extends React.Component {\n    constructor(props) {\n        super(props)\n        this.state = {\n            hover: false,\n            id: '',\n            weight: 0\n        }\n        this.onMouseEnterSquare = this.onMouseEnterSquare.bind(this)\n        this.onMouseLeaveSquare = this.onMouseLeaveSquare.bind(this)\n        this.onClick = this.onClick.bind(this)\n    }\n\n    onMouseEnterSquare() {\n        this.setState({\n            id: 'redBackground',\n            hover: true\n        })\n    }\n\n    onMouseLeaveSquare() {\n        this.setState({\n            id: 'blueBackground',\n            hover: false\n        })\n    }\n    onClick() {\n        this.props.onClick()\n        //this.setWeight()\n\n    }\n    shouldComponentUpdate(nextProps, nextState, nextContext)\n    {\n        if(nextState.id !== this.state.id || this.props.weight !== nextProps.weight || this.props.id !== nextProps.id)\n            return true\n        return false;\n    }\n    render() {\n        let stateId\n        if(!this.state.hover)\n            stateId = this.props.id\n        else\n            stateId = this.state.id\n        return (\n            <Button\n                variant=\"secondary\"\n                className=\"square\"\n                id={stateId}\n                onMouseEnter={this.onMouseEnterSquare.bind()}\n                onMouseLeave={this.onMouseLeaveSquare.bind()}\n                onClick={this.onClick.bind()}>\n                {this.props.weight}\n            </Button>\n        )\n    }\n}\n\nexport default Square\n\n","\n\n//A dictionary has an array containing an array of adjacent nodes, and an entry for the node's parent\n// dict = [[adjacent nodes], parentvalue, index of self]\n// index of self is for Dijkstras\n\n\nconst createContainer = (size, width, blockedNodes)=>\n{//diagonals are also valid\n    let dict = {}\n    for(let i = 0; i < size; i++)\n    {\n        if(blockedNodes[i] !== true)\n        {\n            //A map was likely unnecessary here, but it made keeping track of everything much easier\n            let tempMap = new Map()\n            tempMap.set(\"iPlusOne\", i + 1)\n            tempMap.set(\"iMinusOne\", i - 1)\n            tempMap.set(\"iMinusWidth\", i - width)\n            tempMap.set(\"iMinusWidthMinusOne\", i - width - 1)\n            tempMap.set(\"iMinusWidthPlusOne\", i - width + 1)\n            tempMap.set(\"iPlusWidth\", i + width)\n            tempMap.set(\"iPlusWidthMinusOne\", i + width - 1)\n            tempMap.set(\"iPlusWidthPlusOne\", i + width + 1)\n            for (let [key, value] of tempMap) {\n                if (blockedNodes[value] === true || value < 0 || value >= size) {\n                    tempMap.set(key, -1)\n                }\n            }\n            if (i < width) {\n                if (i < width && i % width === 0) { //top left\n                    dict[i] = [tempMap.get(\"iPlusOne\"), tempMap.get(\"iPlusWidth\"), tempMap.get(\"iPlusWidthPlusOne\")]\n                } else if (i < width && width % i === 1) //top right\n                {\n                    dict[i] = [tempMap.get(\"iMinusOne\"), tempMap.get(\"iPlusWidthMinusOne\"), tempMap.get(\"iPlusWidth\")]\n                } else //first row in the middle\n                {\n                    dict[i] = [tempMap.get(\"iMinusOne\"), tempMap.get(\"iPlusOne\"), tempMap.get(\"iPlusWidthMinusOne\"), tempMap.get(\"iPlusWidth\"), tempMap.get(\"iPlusWidthPlusOne\")]\n                }\n            } else if (i >= size - width) {\n                if (i % width === 0) //bottom left\n                {\n                    dict[i] = [tempMap.get(\"iMinusWidth\"), tempMap.get(\"iMinusWidthPlusOne\"), tempMap.get(\"iPlusOne\")]\n                }\n                else if (i === size - 1) //right side\n                {\n                    dict[i] = [tempMap.get(\"iMinusWidthMinusOne\"), tempMap.get(\"iMinusWidth\"), tempMap.get(\"iMinusWidthPlusOne\"), tempMap.get(\"iMinusOne\"), tempMap.get(\"iPlusOne\")]\n                } else //a center node in the last row\n                {\n                    dict[i] = [tempMap.get(\"iMinusWidthMinusOne\"), tempMap.get(\"iMinusWidth\"), tempMap.get(\"iMinusWidthPlusOne\"), tempMap.get(\"iMinusOne\"), tempMap.get(\"iPlusOne\")]\n                }\n            } else //should be in the center somewhere\n            {\n                if (i % width === 0)//left side not top or bottom row\n                {\n                    dict[i] = [tempMap.get(\"iMinusWidth\"), tempMap.get(\"iMinusWidthPlusOne\"), tempMap.get(\"iPlusOne\"), tempMap.get(\"iPlusWidth\"), tempMap.get(\"iPlusWidthPlusOne\")]\n                } else if (i % width === width - 1) //right side not top or bottom row\n                {\n                    dict[i] = [tempMap.get(\"iMinusWidthMinusOne\"), tempMap.get(\"iMinusWidth\"), tempMap.get(\"iMinusOne\"), tempMap.get(\"iPlusWidthMinusOne\"), tempMap.get(\"iPlusWidth\")]\n                } else {\n                    dict[i] = [tempMap.get(\"iMinusWidthMinusOne\"), tempMap.get(\"iMinusWidth\"), tempMap.get(\"iMinusWidthPlusOne\"), tempMap.get(\"iMinusOne\"), tempMap.get(\"iPlusOne\"), tempMap.get(\"iPlusWidthMinusOne\"), tempMap.get(\"iPlusWidth\"), tempMap.get(\"iPlusWidthPlusOne\")]\n                }\n            }\n            dict[i].sort()\n            let j = 0\n            while(dict[i][j] === -1 && j < dict[i].length)\n            {\n                if(dict[i][j] === -1)\n                {\n                    dict[i].splice(j, 1)\n                }\n                j++\n            }\n            const set = new Set(dict[i])\n            dict[i] = [[...set], null, i]\n        }\n    }\n    return dict\n}\n\nexport default createContainer","\n\n\nexport default class BreathFirstSearch\n{\n    constructor()\n    {\n        this.shortestPathBack = []\n        this.orderOfSearch = []\n        this.BFS = this.BFS.bind(this)\n        this.BFSUtil = this.BFSUtil.bind(this)\n    }\n    BFSUtil(visited, start, end, dictionary, found, orderOfSearch)\n    {\n        const queue = []\n        queue.push(start)\n        visited[start] = true\n        while(queue.length > 0) {\n            let node = queue.shift()\n            orderOfSearch.push(node)\n            if(node === end) {\n                break\n            }\n            for(let i = 0; i < dictionary[node][0].length; i++) {\n                let newNode = dictionary[node][0][i]\n                if(visited[newNode] === false) {\n                    visited[newNode] = true\n                    //console.log(\"this is node: \" + node)\n                    //console.log(\"this is newNode: \" + newNode)\n                    dictionary[newNode][1] = node\n                    queue.push(newNode)\n                }\n            }\n        }\n        this.followPathBack(start, end, dictionary)\n    }\n    followPathBack(start, end, dictionary)\n    {\n        let parent = dictionary[end][1]\n        while(parent !== null){\n            this.shortestPathBack.push(parent)\n            parent = dictionary[parent][1]\n        }\n    }\n    BFS(start, end, dictionary, SIZE)\n    {\n        let visited = Array(SIZE).fill(false)\n        let found = [false]\n        this.BFSUtil(visited, start, end, dictionary, found, this.orderOfSearch)\n        return [this.orderOfSearch, this.shortestPathBack]\n    }\n}\n\n\n\n"," export default class Dijkstra {\n\n     constructor(weights, dictionary, start, end, size)\n     {\n          this.searchingVisited = Array(size).fill(false)\n          this.visited = Array(size).fill(false)\n          this.weights = weights\n          this.distances = Array(size).fill(Infinity)\n          this.distances[start] = -1\n          this.dictionary = dictionary\n          this.start = start\n          this.end = end\n          this.shortestPathBack = []\n          this.orderOfSearch = []\n          this.dijkstra = this.dijkstra.bind(this)\n          this.dijkstraUtil = this.dijkstraUtil.bind(this)\n          this.computeShortestPath = this.computeShortestPath.bind(this)\n     }\n     dijkstra(){\n          this.dijkstraUtil()\n          this.computeShortestPath()\n          //return this.orderOfSearch\n          return [this.orderOfSearch, this.shortestPathBack]\n          //return this.shortestPathBack\n\n     }\n     computeShortestPath()\n     {\n          let index = this.end\n          this.shortestPathBack.push(this.end)\n          while(index !== this.start)\n          {\n               console.log(\"This is the dictionary: \" + this.dictionary[index][0])\n               console.log(\"this is index: \" + index)\n               let minWeight = Infinity\n               let minWeightIndex = -1\n               let node = this.dictionary[index][0]\n               for(let i = 0; i < node.length; i++)\n               {\n                    console.log(\"this is node[i]: \" + node[i])\n                    console.log(\"this is node[i]'s weight\" + this.distances[node[i]])\n                    if(this.distances[node[i]] < minWeight && this.visited[node[i]] === false){\n                         minWeight = this.distances[node[i]]\n                         minWeightIndex = node[i]\n                    }\n               }\n               this.shortestPathBack.push(minWeightIndex)\n               this.visited[minWeightIndex] = true\n               index = minWeightIndex\n               if(index === -1)\n                    return\n          }\n          this.shortestPathBack.push(this.start)\n     }\n     dijkstraUtil(){\n         //this.visited, this.start. this.end, this.dictionary, this.found, this.orderOfSearch\n          let queue =  {...this.dictionary} //shallow copy, should be ok because I do not modify entries\n          while(Object.keys(queue).length > 0) //while not empty\n          {//select node with the minimum distance/weight first run through that will be start node\n               let finalMinDistance = Number.MAX_VALUE\n               let finalMinIndex = -1\n               for( const[key, value] of Object.entries(queue))\n               {\n                    let index = value[2]\n                    if(this.distances[index] < finalMinDistance && this.searchingVisited[index] === false)\n                    {\n                         finalMinDistance = this.distances[index]\n                         finalMinIndex = key //index of node with smallest value in distance array\n                    }\n               }\n               let node = queue[finalMinIndex][0].slice() //pull out adjacent node array\n               this.searchingVisited[finalMinIndex] = true\n               delete queue[finalMinIndex] //remove from queue\n               for(let i = 0; i < node.length; i++) {\n                    const totalDistance = this.distances[finalMinIndex] + this.weights[node[i]]\n                    if (totalDistance < this.distances[node[i]]) {\n                         this.distances[node[i]] = totalDistance\n                         this.orderOfSearch.push(node[i])\n                    }\n               }\n          }\n     console.log(this.distances)\n     }\n }\n\n","import React, {useState} from \"react\";\nimport {useToasts} from \"react-toast-notifications\";\nimport DepthFirstSearch from \"./DepthFirstSearch\";\nimport Button from \"react-bootstrap/Button\";\nimport Square from \"./Square\"\nimport createContainer from \"./CreateContainer\"\nimport BreathFirstSearch from \"./BreathFirstSearch\"\nimport Dijkstra from \"./Dijkstra\"\n\n\nconst Board = (props) => {\n    //can likely optimize blockedNodes\n    const [blockedNodes, setBlockedNodes] = useState(Array(props.height * props.width).fill(false))\n    let [squares, setSquares] = useState(Array(props.height * props.width).fill(false))\n    let [weights, setWeights] = useState(Array(props.height * props.width).fill(1))\n    const [startMarkerIndex, setStartMarkerIndex] = useState(-1)\n    const [dropDownMenu, setDropDownMenu] = useState(false)\n    const [endMarkerIndex, setEndMarkerIndex] = useState(-1)\n    const [clicked, setClicked] = useState(false)\n    const [barrier, setBarrier] = useState(false)\n    const {addToast} = useToasts()\n    const [weightButton, setWeightButton] = useState(false)\n\n    let animateWithoutReturnPath = (arr) => {\n        clearSquares()\n        reDrawBarrier()\n        let tickIndex = 1\n        let timerID2\n        if (clicked === true)\n            return\n\n        const clearTickInterval = () => {\n            clearInterval(timerID2)\n        }\n        const tick2 = (tickArr) => {\n            if (tickIndex < tickArr.length - 1) {\n                //mutating the array directly :/\n                squares[tickArr[tickIndex]] = 'green'\n                tickIndex++\n                setSquares(squares.slice())\n            } else {\n                clearTickInterval(timerID2)\n                setClicked(false)\n                if(tickArr[tickArr.length - 1] === false) {\n                    return (\n                        addToast(\"Path does not exist\", {\n                            appearance: 'warning',\n                            autoDismiss: true,\n                        }))\n                }\n                squares[tickArr[tickArr.length - 1]] = 'gold'\n                setSquares(squares.slice())\n            }\n        }\n        timerID2 = setInterval(\n            () => tick2(arr),\n            10\n        )\n    }\n\n    const setWeight = (count) => {\n            weights[count] = weights[count]+1\n            setWeights(weights.slice())\n    }\n\n    let animateWithReturnPath = (arr) => {\n        const findPathArr = arr[0]\n        const shortestPathArr = arr[1]\n        clearSquares()\n        reDrawBarrier()\n        let tickIndex = 0\n        let timerID2\n        if (clicked === true) {\n            return\n        }\n        const clearTickInterval = () => {\n            clearInterval(timerID2)\n        }\n        let finishedAnimatingFindPath = false\n        const tick2 = (findPathArr, shortestPathArr) => {\n            if(!finishedAnimatingFindPath) {\n                if (tickIndex < findPathArr.length) {\n                    //mutating the array directly -- doesn't seem to update promptly otherwise\n                    console.log(\"this is tickIndex: \" + tickIndex)\n                    console.log(\"this is findPathArr[tickIndex]: \" + findPathArr[tickIndex])\n                    squares[findPathArr[tickIndex]] = 'green'\n                    tickIndex++\n                    setSquares(squares.slice())\n                } else {\n                    finishedAnimatingFindPath = true\n                    squares[endMarkerIndex] = 'gold'\n                    setSquares(squares.slice())\n                    tickIndex = 0\n                }\n            }\n            else\n            {\n                if(tickIndex < shortestPathArr.length - 1)\n                {\n                    squares[shortestPathArr[tickIndex]] = 'gold'\n                    setSquares(squares.slice())\n                    tickIndex++\n                }\n                else{\n                    squares[shortestPathArr[shortestPathArr.length - 1]] = 'gold'\n                    setSquares(squares.slice())\n                    clearTickInterval(timerID2)\n                    setClicked(false)\n                }\n            }\n        }\n        timerID2 = setInterval(\n            () => tick2(findPathArr, shortestPathArr),\n            10\n        )\n    }\n\n    const checkForValidMarkers = () => {\n        if (startMarkerIndex < 0 && endMarkerIndex < 0) {\n            return (\n                addToast(\"Please select a starting and ending location first\", {\n                    appearance: 'warning',\n                    autoDismiss: true,\n                }))\n        } else return null\n    }\n    let dijkstras = () =>\n    {\n        const valid = checkForValidMarkers()\n        if(valid !== null)\n        {\n            return valid\n        }\n        setClicked(true)\n\n        let dict = createContainer(SIZE, WIDTH, blockedNodes)\n        const k = new Dijkstra(weights, dict, startMarkerIndex, endMarkerIndex, SIZE)\n        let shortestPath = k.dijkstra()\n        animateWithReturnPath(shortestPath)\n    }\n    let breathFirstSearch = () => {\n        const valid =checkForValidMarkers()\n        if(valid!== null)\n        {\n            return valid\n        }\n        setClicked(true)\n        const k = new BreathFirstSearch()\n        let dict = createContainer(SIZE, WIDTH, blockedNodes)\n        let shortestPath = k.BFS(startMarkerIndex, endMarkerIndex, dict, SIZE)\n        animateWithReturnPath(shortestPath)\n    }\n    let depthFirstSearch = (SIZE, HEIGHT, WIDTH) => {\n        const valid =checkForValidMarkers()\n        if(valid!== null) {\n            return valid\n        }\n        setClicked(true)\n        const k = new DepthFirstSearch()\n        let dict = createContainer(SIZE, WIDTH, blockedNodes)\n        let shortestPath = k.DFS(startMarkerIndex, endMarkerIndex, dict, SIZE)\n        animateWithoutReturnPath(shortestPath)\n    }\n    let renderSquare = (count) => {\n        let state = 'slateGrey'\n        if (squares[count] === 'gold' || squares[count] === 'green' || squares[count] === 'black')\n            state = squares[count]\n        else if (count === startMarkerIndex)\n            state = 'startMarker'\n        else if (count === endMarkerIndex)\n            state = 'endMarker'\n        return (<Square id={state} index={count} weight = {weights[count]} onClick={fork.bind(this, count)} key={count}/>)\n    }\n    let fork = (i) => {\n        if(weightButton)\n            setWeight(i)\n        else\n            SetMarker(i)\n    }\n    let SetMarker = (i) => {\n        let toastMessage = \"\"\n        let arr = squares.slice()\n        let startStateMarker = startMarkerIndex;\n        let endStateMarker = endMarkerIndex;\n        if (barrier) {\n            blockedNodes[i] = true\n            setBlockedNodes(blockedNodes.slice())\n            squares[i] = 'black'\n            setSquares(squares.slice())\n            return\n        } else if (startStateMarker === i) {\n            startStateMarker = -1\n            arr[i] = undefined\n            toastMessage = \"Deselected Start Location\"\n        } else if (startStateMarker < 0 && endStateMarker === i) {\n            endStateMarker = -1\n            //arr[i] = undefined\n            toastMessage = \"Deselected End Location\"\n        } else if (startStateMarker < 0) {\n            startStateMarker = i\n            //arr[i] = 'O'\n            toastMessage = \"Start Location Selected\"\n        } else if (endStateMarker === i) {\n            endStateMarker = -1\n            //arr[i] = undefined\n            toastMessage = \"Deselected End Location\"\n        } else if (endStateMarker < 0) {\n            endStateMarker = i\n            //arr[i] = 'X'\n            toastMessage = \"Selected End Location\"\n        } else {\n            return\n        }\n        setStartMarkerIndex(startStateMarker)\n        setEndMarkerIndex(endStateMarker)\n        setSquares(squares)\n        return (\n            addToast(toastMessage, {\n                appearance: 'success',\n                autoDismiss: true,\n            }))\n    }\n\n    const clearSquares = () => {\n        //squares not changing without setting squares explicitly\n        squares = Array(props.height * props.width).fill(null)\n        setSquares(Array(props.height * props.width).fill(null))\n\n    }\n    const reDrawBarrier = () =>{\n        for(let i = 0; i < squares.length; i++)\n        {\n            if(blockedNodes[i] === true)\n            {\n                squares[i] = 'black'\n            }\n        }\n        setSquares(Array(squares.slice()))\n    }\n    const clearBarrier = () => {\n        setBlockedNodes(Array(props.height * props.width).fill(false))\n    }\n    const clearMarkers = () => {\n        setStartMarkerIndex(-1)\n        setEndMarkerIndex(-1)\n    }\n    const clearWeights = () => {\n        setWeights(Array(props.height * props.width).fill(1))\n    }\n    const clearGraph = () => {\n        clearSquares()\n        clearBarrier()\n        clearMarkers()\n        clearWeights()\n    }\n    const createBarrier = () => {\n        setBarrier(!barrier)\n        if(weightButton)\n        {\n            setWeightButtonFunction()\n        }\n        if (barrier)\n            document.getElementById(\"barrier\").innerText = \"Draw Barrier\"\n        else\n            document.getElementById(\"barrier\").innerText = \"Disable Barrier\"\n    }\n\n    const setWeightButtonFunction = () =>\n    {\n        setWeightButton(!weightButton)\n        if(barrier)\n        {\n            createBarrier()\n        }\n        if(weightButton)\n            document.getElementById(\"addWeights\").innerText = \"Set Weights\"\n        else\n            document.getElementById(\"addWeights\").innerText = \"Toggle Weights Off\"\n\n    }\n\n    let parent = []\n    let count = 0\n    const HEIGHT = props.height\n    const WIDTH = props.width\n    const SIZE = HEIGHT * WIDTH\n    for (let i = 0; i < HEIGHT; i++) {\n        let children = []\n        for (let j = 0; j < WIDTH; j++) {\n            children.push(renderSquare(count))\n            count++\n        }\n        parent.push(<div key={i} className={\"board-row\"}>{children}</div>)\n    }\n    const toggleOpen = () => setDropDownMenu(!dropDownMenu)\n    const menuClass = `dropdown-menu ${ dropDownMenu? \" show\": \"\"}`\n    return (\n        <div id={\"box\"}>\n            <div id={\"rightBox\"}>\n                <div id = \"buttons\" className = \"btn-group-vertical\" role={\"group\"}>\n                    <div className=\"btn-group\" role=\"group\">\n                        <button id=\"btnGroupDrop1\" type=\"button\"  onClick = {toggleOpen.bind(this)} className=\"btn btn-primary dropdown-toggle\"\n                                data-toggle=\"dropdown-menu\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                            Algorithms\n                        </button>\n                        <div className={menuClass} aria-labelledby=\"btnGroupDrop1\">\n                            <Button className = \"btn btn-primary-dropdown-item\" onClick = {depthFirstSearch.bind(this, SIZE, WIDTH, HEIGHT)} >\n                                Depth First Search\n                                <p> (Does path Exist)</p>\n                          </Button>\n                            <Button className = \"btn btn-primary-dropdown-item\" onClick = {breathFirstSearch.bind(this, SIZE, WIDTH, HEIGHT)} >\n                                Breath-First Search\n                                <p>(Shortest Path)</p>\n                            </Button>\n                            <Button className = \"btn btn-primary-dropdown-item\" onClick = {breathFirstSearch.bind(this, SIZE, WIDTH, HEIGHT)} >\n                                Breath-First Search\n                                <p>(Least Cost Path)</p>\n                                <p> Not Yet Implemented</p>\n                            </Button>\n                            <Button className = \"btn btn-primary-dropdown-item\" onClick = {dijkstras.bind(this, SIZE, WIDTH, HEIGHT)} >\n                                Dijkstra's SPF\n                            </Button>\n                        </div>\n                    </div>\n                    <Button className = \"btn btn-primary-controlButton\" onClick = {clearGraph.bind(this)}>Clear Graph</Button>\n                    <Button className = \"btn btn-primary-controlButton\"  id = \"barrier\" onClick = { createBarrier.bind(this)}>Draw Barrier</Button>\n                    <Button className = \"btn btn-primary-controlButton\" id =\"addWeights\" onClick = { setWeightButtonFunction.bind(this) }>Set Weights</Button>\n                </div>\n            </div>\n        <div id={\"leftBox\"}>\n         {parent}\n        </div>\n\n\n        </div>\n    );\n}\n\nexport default Board\n\n\n/* const OnUpdate = (startMarkerIndex) =>\n {\n     useEffect(() =>\n     {\n         let hell  = parent[1]\n         console.log(hell)\n     })\n }*/\n\n\n/*const OnMount = () => {\n    useEffect(() => {\n        let parent = []\n        let count = 0\n        for (let i = 0; i < HEIGHT; i++) {\n            let children = []\n            for (let j = 0; j < WIDTH; j++) {\n                children.push(renderSquare(count))\n                count++\n            }\n            parent.push(<div key={i} className={\"board-row\"}>{children}</div>)\n        }\n        setParent(parent)\n    }, [])\n\n}\nOnMount()*/\n//OnUpdate(startMarkerIndex)","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport 'bootstrap/dist/css/bootstrap.css'\nimport Board from './Board.js'\nimport {ToastProvider} from \"react-toast-notifications\";\n\nclass Game extends React.Component {\n    constructor(props)\n    {\n        super(props)\n        this.state =({\n            height : 20,\n            width : 20,\n        })\n    }\n    render() {\n        return (\n\n            <div id =\"body\" className=\"game\">\n\n                <div className=\"game-board\">\n                    <ToastProvider autoDismissTimeout={2000} placement=\"bottom-center\">\n                        <Board height = {this.state.height} width = {this.state.width}/>\n                    </ToastProvider>\n                </div>\n\n                <div className=\"game-info\">\n                </div>\n            </div>\n\n        );\n    }\n}\n\nReactDOM.render(\n    <Game />,\n\n\n    document.getElementById('root')\n);\n\n\n"],"sourceRoot":""}