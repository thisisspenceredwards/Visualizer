{"version":3,"sources":["CustomCard.js","DepthFirstSearch.js","Square.js","CreateContainer.js","BreathFirstSearch.js","Dijkstra.js","Board.js","index.js"],"names":["MyCard","props","holder","i","messages","length","push","Card","Title","key","header","Text","className","Header","Button","id","onClick","clearMessages","bind","Body","DepthFirstSearch","this","DFSUtil","DFS","visited","start","end","dictionary","found","orderOfSearch","SIZE","Array","fill","Square","state","hover","weight","onMouseEnterSquare","onMouseLeaveSquare","setState","nextProps","nextState","nextContext","stateId","variant","onMouseEnter","onMouseLeave","React","Component","createContainer","size","width","blockedNodes","dict","tempMap","Map","set","value","get","sort","j","splice","Set","BreathFirstSearch","shortestPathBack","BFS","BFSUtil","queue","node","shift","newNode","followPathBack","parent","Dijkstra","weights","searchingVisited","distances","Infinity","dijkstra","dijkstraUtil","computeShortestPath","index","console","log","minWeight","minWeightIndex","Object","keys","finalMinDistance","Number","MAX_VALUE","finalMinIndex","entries","slice","totalDistance","Board","useState","cardMessages","setCardMessages","backendOrFrontEnd","setBackEndOrFrontEnd","height","setBlockedNodes","squares","setSquares","setWeights","startMarkerIndex","setStartMarkerIndex","dropDownMenu","setDropDownMenu","endMarkerIndex","setEndMarkerIndex","clicked","setClicked","barrier","setBarrier","addToast","useToasts","weightButton","setWeightButton","updateMessages","data","sender","unshift","backendDepthFirstSearch","a","valid","checkForValidMarkers","axios","post","WIDTH","then","res","animateWithoutReturnPath","catch","err","error","backendBreathFirstSearch","HEIGHT","animateWithReturnPath","backendDijkstra","arr","clearSquares","reDrawBarrier","timerID2","tickIndex","tick2","tickArr","clearInterval","appearance","autoDismiss","placement","setInterval","findPathArr","shortestPathArr","finishedAnimatingFindPath","renderSquare","count","fork","setWeight","SetMarker","toastMessage","startStateMarker","endStateMarker","undefined","createBarrier","setWeightButtonFunction","document","getElementById","innerText","children","menuClass","role","type","data-toggle","aria-haspopup","aria-expanded","aria-labelledby","k","shortestPath","Game","autoDismissTimeout","ReactDOM","render"],"mappings":"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","file":"static/js/main.8cb69ff5.chunk.js","sourcesContent":["import Card from \"react-bootstrap/Card\";\nimport Button from \"react-bootstrap/Button\";\nimport React from \"react\";\n\nconst MyCard = (props) =>\n{\n    const holder = [];\n    for(let i = 0; i < props.messages.length; i++)\n    {//values will not be sorted or changed in any way such that using the index for the key should be fine\n        holder.push( <Card.Title key = {\"Title\" + i} >{props.header[i]}</Card.Title>)\n        holder.push(  <Card.Text key = {\"Message\" + i}>{props.messages[i]}</Card.Text>)\n    }\n    return (\n    <Card className=\"text-center\">\n        <Card.Header>\n            <Button id={\"headerButton\"} onClick = {props.clearMessages.bind(this)}>Clear Messages</Button>\n            Messages Sent and Received\n        </Card.Header>\n        <Card.Body>\n            {holder}\n        </Card.Body>\n    </Card>)\n}\nexport default MyCard","export default class DepthFirstSearch\n{\n    constructor()\n    {\n        this.DFSUtil = this.DFSUtil.bind(this)\n        this.DFS = this.DFS.bind(this)\n    }\n    DFSUtil(visited, start, end, dictionary, found, orderOfSearch)\n    {\n        if(found[0] === true) return  //stop the search\n        if(start === end) //eureka!\n        {\n            found[0] = true\n            visited[start] = true\n            orderOfSearch.push(start)\n        }\n        visited[start] = true\n        orderOfSearch.push(start) //this is to track the order of visited nodes\n\n        for(let i = 0; i < dictionary[start][0].length; i++)\n        {\n            if(dictionary[i][0] !== -1 && visited[dictionary[start][0][i]] === false)\n            {\n                this.DFSUtil(visited, dictionary[start][0][i], end, dictionary, found, orderOfSearch)\n            }\n        }\n    }\n    DFS(start, end, dictionary, SIZE){\n        let visited = Array(SIZE).fill(false)\n        let orderOfSearch = []\n        let found = [false]\n        this.DFSUtil(visited, start, end, dictionary, found, orderOfSearch)\n        if(found[0] === false)\n        {\n            return [...orderOfSearch, false]\n        }\n        return orderOfSearch\n    }\n}\n\n\n\n\n\n\n","import React from \"react\";\nimport Button from \"react-bootstrap/Button\";\nclass Square extends React.Component {\n    constructor(props) {\n        super(props)\n        this.state = {\n            hover: false,\n            id: '',\n            weight: 0\n        }\n        this.onMouseEnterSquare = this.onMouseEnterSquare.bind(this)\n        this.onMouseLeaveSquare = this.onMouseLeaveSquare.bind(this)\n        this.onClick = this.onClick.bind(this)\n    }\n\n    onMouseEnterSquare() {\n        this.setState({\n            id: 'redBackground',\n            hover: true\n        })\n    }\n\n    onMouseLeaveSquare() {\n        this.setState({\n            id: 'blueBackground',\n            hover: false\n        })\n    }\n    onClick() {\n        this.props.onClick()\n        //this.setWeight()\n\n    }\n    shouldComponentUpdate(nextProps, nextState, nextContext)\n    {\n        if(nextState.id !== this.state.id || this.props.weight !== nextProps.weight || this.props.id !== nextProps.id)\n            return true\n        return false;\n    }\n    render() {\n        let stateId\n        if(!this.state.hover)\n            stateId = this.props.id\n        else\n            stateId = this.state.id\n        return (\n            <Button\n                variant=\"secondary\"\n                className=\"square\"\n                id={stateId}\n                onMouseEnter={this.onMouseEnterSquare.bind()}\n                onMouseLeave={this.onMouseLeaveSquare.bind()}\n                onClick={this.onClick.bind()}>\n                {this.props.weight}\n            </Button>\n        )\n    }\n}\n\nexport default Square\n\n","\n\n//A dictionary has an array containing an array of adjacent nodes, and an entry for the node's parent\n// dict = [[adjacent nodes], parentvalue, index of self]\n// index of self is for Dijkstras\n\n\nconst createContainer = (size, width, blockedNodes)=>\n{//diagonals are also valid\n    let dict = {}\n    for(let i = 0; i < size; i++)\n    {\n        if(blockedNodes[i] !== true)\n        {\n            //A map was likely unnecessary here, but it made keeping track of everything much easier\n            let tempMap = new Map()\n            tempMap.set(\"iPlusOne\", i + 1)\n            tempMap.set(\"iMinusOne\", i - 1)\n            tempMap.set(\"iMinusWidth\", i - width)\n            tempMap.set(\"iMinusWidthMinusOne\", i - width - 1)\n            tempMap.set(\"iMinusWidthPlusOne\", i - width + 1)\n            tempMap.set(\"iPlusWidth\", i + width)\n            tempMap.set(\"iPlusWidthMinusOne\", i + width - 1)\n            tempMap.set(\"iPlusWidthPlusOne\", i + width + 1)\n            for (let [key, value] of tempMap) {\n                if (blockedNodes[value] === true || value < 0 || value >= size) {\n                    tempMap.set(key, -1)\n                }\n            }\n            if (i < width) {\n                if (i < width && i % width === 0) { //top left\n                    dict[i] = [tempMap.get(\"iPlusOne\"), tempMap.get(\"iPlusWidth\"), tempMap.get(\"iPlusWidthPlusOne\")]\n                } else if (i < width && width % i === 1) //top right\n                {\n                    dict[i] = [tempMap.get(\"iMinusOne\"), tempMap.get(\"iPlusWidthMinusOne\"), tempMap.get(\"iPlusWidth\")]\n                } else //first row in the middle\n                {\n                    dict[i] = [tempMap.get(\"iMinusOne\"), tempMap.get(\"iPlusOne\"), tempMap.get(\"iPlusWidthMinusOne\"), tempMap.get(\"iPlusWidth\"), tempMap.get(\"iPlusWidthPlusOne\")]\n                }\n            } else if (i >= size - width) {\n                if (i % width === 0) //bottom left\n                {\n                    dict[i] = [tempMap.get(\"iMinusWidth\"), tempMap.get(\"iMinusWidthPlusOne\"), tempMap.get(\"iPlusOne\")]\n                }\n                else if (i === size - 1) //right side\n                {\n                    dict[i] = [tempMap.get(\"iMinusWidthMinusOne\"), tempMap.get(\"iMinusWidth\"), tempMap.get(\"iMinusWidthPlusOne\"), tempMap.get(\"iMinusOne\"), tempMap.get(\"iPlusOne\")]\n                } else //a center node in the last row\n                {\n                    dict[i] = [tempMap.get(\"iMinusWidthMinusOne\"), tempMap.get(\"iMinusWidth\"), tempMap.get(\"iMinusWidthPlusOne\"), tempMap.get(\"iMinusOne\"), tempMap.get(\"iPlusOne\")]\n                }\n            } else //should be in the center somewhere\n            {\n                if (i % width === 0)//left side not top or bottom row\n                {\n                    dict[i] = [tempMap.get(\"iMinusWidth\"), tempMap.get(\"iMinusWidthPlusOne\"), tempMap.get(\"iPlusOne\"), tempMap.get(\"iPlusWidth\"), tempMap.get(\"iPlusWidthPlusOne\")]\n                } else if (i % width === width - 1) //right side not top or bottom row\n                {\n                    dict[i] = [tempMap.get(\"iMinusWidthMinusOne\"), tempMap.get(\"iMinusWidth\"), tempMap.get(\"iMinusOne\"), tempMap.get(\"iPlusWidthMinusOne\"), tempMap.get(\"iPlusWidth\")]\n                } else {\n                    dict[i] = [tempMap.get(\"iMinusWidthMinusOne\"), tempMap.get(\"iMinusWidth\"), tempMap.get(\"iMinusWidthPlusOne\"), tempMap.get(\"iMinusOne\"), tempMap.get(\"iPlusOne\"), tempMap.get(\"iPlusWidthMinusOne\"), tempMap.get(\"iPlusWidth\"), tempMap.get(\"iPlusWidthPlusOne\")]\n                }\n            }\n            dict[i].sort()\n            let j = 0\n            while(dict[i][j] === -1 && j < dict[i].length)\n            {\n                if(dict[i][j] === -1)\n                {\n                    dict[i].splice(j, 1)\n                }\n                j++\n            }\n            const set = new Set(dict[i])\n            dict[i] = [[...set], null, i]\n        }\n    }\n    return dict\n}\n\nexport default createContainer","export default class BreathFirstSearch\n{\n    constructor()\n    {\n        this.shortestPathBack = []\n        this.orderOfSearch = []\n        this.BFS = this.BFS.bind(this)\n        this.BFSUtil = this.BFSUtil.bind(this)\n    }\n    BFSUtil(visited, start, end, dictionary, found, orderOfSearch)\n    {\n        const queue = []\n        queue.push(start)\n        visited[start] = true\n        while(queue.length > 0) {\n            let node = queue.shift()\n            orderOfSearch.push(node)\n            if(node === end) {\n                break\n            }\n            for(let i = 0; i < dictionary[node][0].length; i++) {\n                let newNode = dictionary[node][0][i]\n                if(visited[newNode] === false) {\n                    visited[newNode] = true\n                    //console.log(\"this is node: \" + node)\n                    //console.log(\"this is newNode: \" + newNode)\n                    dictionary[newNode][1] = node\n                    queue.push(newNode)\n                }\n            }\n        }\n        this.followPathBack(start, end, dictionary)\n    }\n    followPathBack(start, end, dictionary)\n    {\n        let parent = dictionary[end][1]\n        while(parent !== null){\n            this.shortestPathBack.push(parent)\n            parent = dictionary[parent][1]\n        }\n    }\n    BFS(start, end, dictionary, SIZE)\n    {\n        let visited = Array(SIZE).fill(false)\n        let found = [false]\n        this.BFSUtil(visited, start, end, dictionary, found, this.orderOfSearch)\n        return [this.orderOfSearch, this.shortestPathBack]\n    }\n}\n\n\n\n"," export default class Dijkstra {\n\n     constructor(weights, dictionary, start, end, size)\n     {\n          this.searchingVisited = Array(size).fill(false)\n          this.visited = Array(size).fill(false)\n          this.weights = weights\n          this.distances = Array(size).fill(Infinity)\n          this.distances[start] = -1\n          this.dictionary = dictionary\n          this.start = start\n          this.end = end\n          this.shortestPathBack = []\n          this.orderOfSearch = []\n          this.dijkstra = this.dijkstra.bind(this)\n          this.dijkstraUtil = this.dijkstraUtil.bind(this)\n          this.computeShortestPath = this.computeShortestPath.bind(this)\n     }\n     dijkstra(){\n          this.dijkstraUtil()\n          this.computeShortestPath()\n          //return this.orderOfSearch\n          return [this.orderOfSearch, this.shortestPathBack]\n          //return this.shortestPathBack\n\n     }\n     computeShortestPath()\n     {\n          let index = this.end\n          this.shortestPathBack.push(this.end)\n          while(index !== this.start)\n          {\n               console.log(\"This is the dictionary: \" + this.dictionary[index][0])\n               console.log(\"this is index: \" + index)\n               let minWeight = Infinity\n               let minWeightIndex = -1\n               let node = this.dictionary[index][0]\n               for(let i = 0; i < node.length; i++)\n               {\n                    console.log(\"this is node[i]: \" + node[i])\n                    console.log(\"this is node[i]'s weight\" + this.distances[node[i]])\n                    if(this.distances[node[i]] < minWeight && this.visited[node[i]] === false){\n                         minWeight = this.distances[node[i]]\n                         minWeightIndex = node[i]\n                    }\n               }\n               this.shortestPathBack.push(minWeightIndex)\n               this.visited[minWeightIndex] = true\n               index = minWeightIndex\n               if(index === -1)\n                    return\n          }\n          this.shortestPathBack.push(this.start)\n     }\n     dijkstraUtil(){\n         //this.visited, this.start. this.end, this.dictionary, this.found, this.orderOfSearch\n          let queue =  {...this.dictionary} //shallow copy, should be ok because I do not modify entries\n          while(Object.keys(queue).length > 0) //while not empty\n          {//select node with the minimum distance/weight first run through that will be start node\n               let finalMinDistance = Number.MAX_VALUE\n               let finalMinIndex = -1\n               for( const[key, value] of Object.entries(queue))\n               {\n                    let index = value[2]\n                    if(this.distances[index] < finalMinDistance && this.searchingVisited[index] === false)\n                    {\n                         finalMinDistance = this.distances[index]\n                         finalMinIndex = key //index of node with smallest value in distance array\n                    }\n               }\n               let node = queue[finalMinIndex][0].slice() //pull out adjacent node array\n               this.searchingVisited[finalMinIndex] = true\n               delete queue[finalMinIndex] //remove from queue\n               for(let i = 0; i < node.length; i++) {\n                    const totalDistance = this.distances[finalMinIndex] + this.weights[node[i]]\n                    if (totalDistance < this.distances[node[i]]) {\n                         this.distances[node[i]] = totalDistance\n                         this.orderOfSearch.push(node[i])\n                    }\n               }\n          }\n     console.log(this.distances)\n     }\n }\n\n","import React, {useState} from \"react\";\nimport MyCard from \"./CustomCard\"\nimport {useToasts} from \"react-toast-notifications\";\nimport DepthFirstSearch from \"./DepthFirstSearch\";\nimport Button from \"react-bootstrap/Button\";\nimport Square from \"./Square\"\nimport createContainer from \"./CreateContainer\"\nimport BreathFirstSearch from \"./BreathFirstSearch\"\nimport Dijkstra from \"./Dijkstra\"\nimport axios from \"axios\"\n\n\nconst Board = (props) => {\n    //can likely optimize blockedNodes\n    let [cardMessages, setCardMessages] = useState([])\n    let [backendOrFrontEnd, setBackEndOrFrontEnd] = useState([])\n    const [blockedNodes, setBlockedNodes] = useState(Array(props.height * props.width).fill(false))\n    let [squares, setSquares] = useState(Array(props.height * props.width).fill(false))\n    let [weights, setWeights] = useState(Array(props.height * props.width).fill(1))\n    const [startMarkerIndex, setStartMarkerIndex] = useState(-1)\n    const [dropDownMenu, setDropDownMenu] = useState(false)\n    const [endMarkerIndex, setEndMarkerIndex] = useState(-1)\n    const [clicked, setClicked] = useState(false)\n    const [barrier, setBarrier] = useState(false)\n    const {addToast} = useToasts()\n    const [weightButton, setWeightButton] = useState(false)\n\n    const updateMessages = (data, sender) =>\n    {\n        cardMessages.unshift(data)\n        backendOrFrontEnd.unshift(sender)\n        setCardMessages(cardMessages)\n        setBackEndOrFrontEnd(backendOrFrontEnd)\n    }\n    const backendDepthFirstSearch = async () =>\n    {\n        const valid =checkForValidMarkers()\n        if(valid!== null) {\n            return valid\n        }\n        setClicked(true)\n        updateMessages('Sending data for DFS', 'frontend')\n        await axios.post('https://visualizerbackend.herokuapp.com/depthFirstSearch', {startMarkerIndex, endMarkerIndex, SIZE, WIDTH, blockedNodes})\n            .then(res=>{\n                updateMessages(res.data[0], 'backend')\n                animateWithoutReturnPath(res.data[1])\n            })\n            .catch(err => {console.error(err)})\n    }\n    let backendBreathFirstSearch = async () => {\n        const valid =checkForValidMarkers()\n        if(valid!== null)\n        {\n            return valid\n        }\n        setClicked(true)\n        updateMessages('Sending data for BFS', 'frontend')\n        await axios.post('https://visualizerbackend.herokuapp.com/breathFirstSearch', {startMarkerIndex, endMarkerIndex, SIZE, WIDTH, HEIGHT, squares, blockedNodes, weights })\n            .then(res=>{\n                updateMessages(res.data[0], 'backend')\n                animateWithReturnPath(res.data[1])\n            })\n            .catch(err => {console.error(err)})\n        //const k = new BreathFirstSearch()\n        //let dict = createContainer(SIZE, WIDTH, blockedNodes)\n        //let shortestPath = k.BFS(startMarkerIndex, endMarkerIndex, dict, SIZE)\n        //animateWithReturnPath(shortestPath)\n    }\n    let backendDijkstra = async () =>\n    {\n        const valid = checkForValidMarkers()\n        if(valid !== null)\n        {\n            return valid\n        }\n        setClicked(true)\n        updateMessages('Sending data for Dijkstra', 'frontend')\n        await axios.post('https://visualizerbackend.herokuapp.com/dijkstra', {startMarkerIndex, endMarkerIndex, SIZE, WIDTH, blockedNodes, weights })\n            .then(res=>{\n                updateMessages(res.data[0], 'backend')\n                animateWithReturnPath(res.data[1])\n            })\n            .catch(err => {console.error(err)})\n        //let dict = createContainer(SIZE, WIDTH, blockedNodes)\n        //const k = new Dijkstra(weights, dict, startMarkerIndex, endMarkerIndex, SIZE)\n        //let shortestPath = k.dijkstra()\n        //animateWithReturnPath(shortestPath)\n    }\n\n    let animateWithoutReturnPath = (arr) => {\n        clearSquares()\n        reDrawBarrier()\n        let tickIndex = 1\n        let timerID2\n        if (clicked === true)\n            return\n\n        const clearTickInterval = () => {\n            clearInterval(timerID2)\n        }\n        const tick2 = (tickArr) => {\n            if (tickIndex < tickArr.length - 1) {\n                //mutating the array directly :/\n                squares[tickArr[tickIndex]] = 'green'\n                tickIndex++\n                setSquares(squares.slice())\n            } else {\n                clearTickInterval(timerID2)\n                setClicked(false)\n                if(tickArr[tickArr.length - 1] === false) {\n                    return (\n                        addToast(\"Path does not exist\", {\n                            appearance: 'warning',\n                            autoDismiss: true,\n                        }))\n                }\n                squares[tickArr[tickArr.length - 1]] = 'gold'\n                setSquares(squares.slice())\n                return (\n                    addToast(\"Path does exist\", {\n                        placement: 'top-middle',\n                        appearance: 'success',\n                        autoDismiss: true,\n                    }))\n            }\n        }\n        timerID2 = setInterval(\n            () => tick2(arr),\n            10\n        )\n    }\n\n    let animateWithReturnPath = (arr) => {\n        const findPathArr = arr[0]\n        const shortestPathArr = arr[1]\n        clearSquares()\n        reDrawBarrier()\n        let tickIndex = 0\n        let timerID2\n        if (clicked === true) {\n            return\n        }\n        const clearTickInterval = () => {\n            clearInterval(timerID2)\n        }\n        let finishedAnimatingFindPath = false\n        const tick2 = (findPathArr, shortestPathArr) => {\n            if(!finishedAnimatingFindPath) {\n                if (tickIndex < findPathArr.length) {\n                    //mutating the array directly -- doesn't seem to update promptly otherwise\n                    //console.log(\"this is tickIndex: \" + tickIndex)\n                    //console.log(\"this is findPathArr[tickIndex]: \" + findPathArr[tickIndex])\n                    if(!(findPathArr[tickIndex] === endMarkerIndex) && !(findPathArr[tickIndex] === startMarkerIndex))\n                        squares[findPathArr[tickIndex]] = 'green'\n                    tickIndex++\n                    setSquares(squares.slice())\n                } else {\n                    finishedAnimatingFindPath = true\n                    squares[endMarkerIndex] = 'gold'\n                    setSquares(squares.slice())\n                    tickIndex = 0\n                }\n            }\n            else\n            {\n                if(tickIndex < shortestPathArr.length - 1)\n                {\n                    squares[shortestPathArr[tickIndex]] = 'gold'\n                    setSquares(squares.slice())\n                    tickIndex++\n                }\n                else{\n                    squares[shortestPathArr[shortestPathArr.length - 1]] = 'gold'\n                    setSquares(squares.slice())\n                    clearTickInterval(timerID2)\n                    setClicked(false)\n                }\n            }\n        }\n        timerID2 = setInterval(\n            () => tick2(findPathArr, shortestPathArr),\n            10\n        )\n    }\n\n    const setWeight = (count) => {\n        weights[count] = weights[count]+1\n        setWeights(weights.slice())\n    }\n\n    const checkForValidMarkers = () => {\n        if (startMarkerIndex < 0 && endMarkerIndex < 0) {\n            return (\n                addToast(\"Please select a starting and ending location first\", {\n                    appearance: 'warning',\n                    autoDismiss: true,\n                }))\n        } else return null\n    }\n    let dijkstra = () =>\n    {\n        const valid = checkForValidMarkers()\n        if(valid !== null)\n        {\n            return valid\n        }\n        setClicked(true)\n\n        let dict = createContainer(SIZE, WIDTH, blockedNodes)\n        const k = new Dijkstra(weights, dict, startMarkerIndex, endMarkerIndex, SIZE)\n        let shortestPath = k.dijkstra()\n        animateWithReturnPath(shortestPath)\n    }\n    let breathFirstSearch = () => {\n        const valid =checkForValidMarkers()\n        if(valid!== null)\n        {\n            return valid\n        }\n        setClicked(true)\n        const k = new BreathFirstSearch()\n        let dict = createContainer(SIZE, WIDTH, blockedNodes)\n        let shortestPath = k.BFS(startMarkerIndex, endMarkerIndex, dict, SIZE)\n        animateWithReturnPath(shortestPath)\n    }\n    let depthFirstSearch = (SIZE, HEIGHT, WIDTH) => {\n        const valid =checkForValidMarkers()\n        if(valid!== null) {\n            return valid\n        }\n        setClicked(true)\n        const k = new DepthFirstSearch()\n        let dict = createContainer(SIZE, WIDTH, blockedNodes)\n        let shortestPath = k.DFS(startMarkerIndex, endMarkerIndex, dict, SIZE)\n        animateWithoutReturnPath(shortestPath)\n    }\n    let renderSquare = (count) => {\n        let state = 'slateGrey'\n        if (squares[count] === 'gold' || squares[count] === 'green' || squares[count] === 'black')\n            state = squares[count]\n        else if (count === startMarkerIndex)\n            state = 'startMarker'\n        else if (count === endMarkerIndex)\n            state = 'endMarker'\n        return (<Square id={state} index={count} weight = {weights[count]} onClick={fork.bind(this, count)} key={count}/>)\n    }\n    let fork = (i) => {\n        if(weightButton)\n            setWeight(i)\n        else\n            SetMarker(i)\n    }\n    let SetMarker = (i) => {\n        let toastMessage = \"\"\n        let arr = squares.slice()\n        let startStateMarker = startMarkerIndex;\n        let endStateMarker = endMarkerIndex;\n        if (barrier) {\n            blockedNodes[i] = true\n            setBlockedNodes(blockedNodes.slice())\n            squares[i] = 'black'\n            setSquares(squares.slice())\n            return\n        } else if (startStateMarker === i) {\n            startStateMarker = -1\n            arr[i] = undefined\n            toastMessage = \"Deselected Start Location\"\n        } else if (startStateMarker < 0 && endStateMarker === i) {\n            endStateMarker = -1\n            //arr[i] = undefined\n            toastMessage = \"Deselected End Location\"\n        } else if (startStateMarker < 0) {\n            startStateMarker = i\n            //arr[i] = 'O'\n            toastMessage = \"Start Location Selected\"\n        } else if (endStateMarker === i) {\n            endStateMarker = -1\n            //arr[i] = undefined\n            toastMessage = \"Deselected End Location\"\n        } else if (endStateMarker < 0) {\n            endStateMarker = i\n            //arr[i] = 'X'\n            toastMessage = \"Selected End Location\"\n        } else {\n            return\n        }\n        setStartMarkerIndex(startStateMarker)\n        setEndMarkerIndex(endStateMarker)\n        setSquares(squares)\n        return (\n            addToast(toastMessage, {\n                appearance: 'info',\n                autoDismiss: true,\n            }))\n    }\n\n    const clearSquares = () => {\n        //squares not changing without setting squares explicitly\n        squares = Array(props.height * props.width).fill(null)\n        setSquares(Array(props.height * props.width).fill(null))\n\n    }\n    const reDrawBarrier = () =>{\n        for(let i = 0; i < squares.length; i++)\n        {\n            if(blockedNodes[i] === true)\n            {\n                squares[i] = 'black'\n            }\n        }\n        setSquares(Array(squares.slice()))\n    }\n    const clearBarrier = () => {\n        setBlockedNodes(Array(props.height * props.width).fill(false))\n    }\n    const clearMarkers = () => {\n        setStartMarkerIndex(-1)\n        setEndMarkerIndex(-1)\n    }\n    const clearWeights = () => {\n        setWeights(Array(props.height * props.width).fill(1))\n    }\n    const clearGraph = () => {\n        clearSquares()\n        clearBarrier()\n        clearMarkers()\n        clearWeights()\n    }\n    const createBarrier = () => {\n        setBarrier(!barrier)\n        if(weightButton)\n        {\n            setWeightButtonFunction()\n        }\n        if (barrier)\n            document.getElementById(\"barrier\").innerText = \"Draw Barrier\"\n        else\n            document.getElementById(\"barrier\").innerText = \"Disable Barrier\"\n    }\n\n    const setWeightButtonFunction = () =>\n    {\n        setWeightButton(!weightButton)\n        if(barrier)\n        {\n            createBarrier()\n        }\n        if(weightButton)\n            document.getElementById(\"addWeights\").innerText = \"Set Weights\"\n        else\n            document.getElementById(\"addWeights\").innerText = \"Toggle Weights Off\"\n\n    }\n    const clearCardMessages = () =>\n    {\n        setCardMessages([])\n        setBackEndOrFrontEnd([])\n    }\n\n\n\n\n    let parent = []\n    let count = 0\n    const HEIGHT = props.height\n    const WIDTH = props.width\n    const SIZE = HEIGHT * WIDTH\n    for (let i = 0; i < HEIGHT; i++) {\n        let children = []\n        for (let j = 0; j < WIDTH; j++) {\n            children.push(renderSquare(count))\n            count++\n        }\n        parent.push(<div key={i} className={\"board-row\"}>{children}</div>)\n    }\n    const toggleOpen = () => setDropDownMenu(!dropDownMenu)\n    const menuClass = `dropdown-menu ${ dropDownMenu? \" show\": \"\"}`\n    return (\n        <div id={\"box\"}>\n            <div id={\"leftBox\"}>\n                    <div id = \"buttons\" className = \"btn-group-vertical\" role={\"group\"}>\n                    <div className=\"btn-group\" role=\"group\">\n                        <button id=\"btnGroupDrop1\" type=\"button\"  onClick = {toggleOpen.bind(this)} className=\"btn btn-primary dropdown-toggle\"\n                                data-toggle=\"dropdown-menu\" aria-haspopup=\"true\" aria-expanded=\"false\">\n                            Algorithms\n                        </button>\n                        <div className={menuClass} aria-labelledby=\"btnGroupDrop1\">\n                            <a id={\"menuButton\"} className = \"btn btn-primary-dropdown-item\" onClick = {depthFirstSearch.bind(this, SIZE, WIDTH, HEIGHT)} >\n                                Depth First Search\n                                <p> (Does path Exist)</p>\n                          </a>\n                            <a id={\"menuButton\"} className = \"btn btn-primary-dropdown-item\" onClick = {breathFirstSearch.bind(this, SIZE, WIDTH, HEIGHT)} >\n                                Breath-First Search\n                                <p>(Shortest Path)</p>\n                            </a>\n                            <a id={\"menuButton\"} className = \"btn btn-primary-dropdown-item\" onClick = {dijkstra.bind(this, SIZE, WIDTH, HEIGHT)} >\n                                Dijkstra's SPF\n                            </a>\n                        </div>\n                    </div>\n                    <Button className = \"btn btn-primary-controlButton\" onClick = {clearGraph.bind(this)}>Clear Graph</Button>\n                    <Button className = \"btn btn-primary-controlButton\"  id = \"barrier\" onClick = { createBarrier.bind(this)}>Draw Barrier</Button>\n                    <Button className = \"btn btn-primary-controlButton\" id =\"addWeights\" onClick = { setWeightButtonFunction.bind(this) }>Set Weights</Button>\n                        <Button className = \"btn btn-primary-controlButton\" id =\"addWeights\" onClick = { backendDepthFirstSearch.bind(this) }>Backend DFS</Button>\n                        <Button className = \"btn btn-primary-controlButton\" id =\"addWeights\" onClick = { backendBreathFirstSearch.bind(this) }>Backend BFS</Button>\n                        <Button className = \"btn btn-primary-controlButton\" id =\"addWeights\" onClick = { backendDijkstra.bind(this) }>Backend Dijkstra</Button>\n                    </div>\n            </div>\n        <div id={\"centerBox\"}>\n         {parent}\n        </div>\n            <div id={\"rightBox\"}>\n                  <MyCard clearMessages = {clearCardMessages.bind(this)} messages = {cardMessages} header = {backendOrFrontEnd} />\n            </div>\n\n\n\n        </div>\n    );\n}\n\nexport default Board\n\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport 'bootstrap/dist/css/bootstrap.css'\nimport Board from './Board.js'\nimport {ToastProvider} from \"react-toast-notifications\";\n\nclass Game extends React.Component {\n    constructor(props)\n    {\n        super(props)\n        this.state =({\n            height : 20,\n            width : 20,\n        })\n    }\n    render() {\n        return (\n\n            <div id =\"body\" className=\"game\">\n\n                <div className=\"game-board\">\n                    <ToastProvider autoDismissTimeout={2000} placement=\"bottom-center\">\n                        <Board height = {this.state.height} width = {this.state.width}/>\n                    </ToastProvider>\n                </div>\n\n                <div className=\"game-info\">\n                </div>\n            </div>\n\n        );\n    }\n}\n\nReactDOM.render(\n    <Game />,\n\n\n    document.getElementById('root')\n);\n\n\n"],"sourceRoot":""}